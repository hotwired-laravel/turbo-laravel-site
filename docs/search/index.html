<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="canonical" href="https://turbo-laravel.com/docs/search">
        <meta name="description" content="Build web and hybrid navite apps with Laravel and Hotwire today.">
        <title>Turbo Laravel | Turbo Laravel</title>
        <link rel="apple-touch-icon" sizes="180x180" href="https://turbo-laravel.com/assets/manifest/apple-touch-icon.png">
        <link rel="icon" type="image/png" sizes="32x32" href="https://turbo-laravel.com/assets/manifest/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="https://turbo-laravel.com/assets/manifest/favicon-16x16.png">
        <link rel="manifest" href="https://turbo-laravel.com/assets/site.webmanifest">
        <link rel="preload" href="https://turbo-laravel.com/assets/fonts/OpenSans-ExtraBold.ttf" as="font" type="font/ttf" crossorigin>
        <link rel="preload" href="https://turbo-laravel.com/assets/fonts/Jost-Regular.woff2" as="font" type="font/woff2" crossorigin>
        <link rel="preload" href="https://turbo-laravel.com/assets/fonts/Jost-Italic.woff2" as="font" type="font/woff2" crossorigin>
        <link rel="stylesheet" href="/assets/build/css/main.css?id=6b05837cc65a091f2f0479773b06a85f">
        <script defer src="/assets/build/js/main.js?id=b0f29cd4e71d41b4ee570d0f42344180"></script>

        <!-- Open Graph data -->
        <meta property="og:title" content="Turbo Laravel | Turbo Laravel" />
        <meta property="og:type" content="website" />
        <meta property="og:url" content="" />

        <meta property="og:image" content="https://turbo-laravel.com/assets/images/turbo-laravel-meta.png" />
        <meta property="og:image:height" content="630" />
        <meta property="og:image:width" content="1200" />
        <meta property="og:description" content="Build web and hybrid navite apps with Laravel and Hotwire today." />
        <meta property="og:locale" content="en_US">
        <meta property="og:site_name" content="Turbo Laravel" />

        <!-- Twitter Card meta -->
        <meta name="twitter:card" content="summary_large_image">
        <meta name="twitter:title" content="Turbo Laravel | Turbo Laravel">
        <meta name="twitter:description" content="Build web and hybrid navite apps with Laravel and Hotwire today.">
    </head>
    <body class="text-zinc-900 text-lg font-sans antialiased bg-zinc-700/5 min-h-screen" data-controller="search" data-action="keydown@window->search#focus">
        <header class="px-4 py-6 lg:px-10 xl:px-20 lg:py-10 flex items-center space-x-2 justify-between">
  <div class="relative flex-1 lg:flex-auto flex justify-between items-center space-x-4 sm:space-x-2">
    <h1 class="text-3xl sm:text-4xl font-extrabold font-heading">
      <a href="/">Turbo Laravel</a>
    </h1>

    <nav class="inline-block lg:hidden">
      <details class="group" data-search-target="nav">
        <summary class="list-none">
          <span>
            <span class="sr-only">Navigation</span>

            <svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="size-8 rotate-0 transition group-open:rotate-90">
              <path class="opacity-100 transition group-open:opacity-0" stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5" />
              <path class="transition opacity-0 group-open:opacity-100" stroke-linecap="round" stroke-linejoin="round" d="M6 18 18 6M6 6l12 12" />
            </svg>
          </span>
        </summary>

        <div class="bg-white/50 z-10 absolute top-12 -inset-x-4 backdrop-blur-xl">
          <div class="bg-zinc-700/5 px-4 py-6 backdrop-blur">
            <form action="/docs/search" method="GET" class="px-4">
  <label for="search" class="sr-only">Search</label>
  <input data-search-target="mobile" type="search" name="q" class="search-input rounded border border-zinc-900/5 px-4 py-2 text-base leading-3 shadow w-full" placeholder="Search 2.x docs..." />
  <button type="submit" class="sr-only">Search</button>
</form>

            <ul class="space-y-6 -mb-2 mt-4">
              <li>
                <a href="/docs" class="px-4 py-2 font-medium rounded-full transition hover:bg-white/90 flex items-center space-x-1">
                  <span>Documentation</span>
                </a>

                  <div class="mx-4 pl-3 border-l-4 border-zinc-900/30">
  <ul class="">
        <li class="px-2 py-1 font-heading font-extrabold uppercase text-sm text-zinc-900/40">Prologue</li>
    <li class="children mt-2">
      <ul class="list-inside space-y-1 text-lg">
                <li><a href="/docs/upgrade" class=" transition hover:bg-zinc-900/20 w-full inline-block px-2 py-1">Upgrade Guide</a></li>
              </ul>
    </li>
        <li class="px-2 py-1 font-heading font-extrabold uppercase text-sm text-zinc-900/40">Getting Started</li>
    <li class="children mt-2">
      <ul class="list-inside space-y-1 text-lg">
                <li><a href="/docs/installation" class=" transition hover:bg-zinc-900/20 w-full inline-block px-2 py-1">Installation</a></li>
                <li><a href="/docs/overview" class=" transition hover:bg-zinc-900/20 w-full inline-block px-2 py-1">Overview</a></li>
                <li><a href="/docs/conventions" class=" transition hover:bg-zinc-900/20 w-full inline-block px-2 py-1">Conventions</a></li>
              </ul>
    </li>
        <li class="px-2 py-1 font-heading font-extrabold uppercase text-sm text-zinc-900/40">Essentials</li>
    <li class="children mt-2">
      <ul class="list-inside space-y-1 text-lg">
                <li><a href="/docs/helpers" class=" transition hover:bg-zinc-900/20 w-full inline-block px-2 py-1">Helpers</a></li>
                <li><a href="/docs/turbo-frames" class=" transition hover:bg-zinc-900/20 w-full inline-block px-2 py-1">Turbo Frames</a></li>
                <li><a href="/docs/turbo-streams" class=" transition hover:bg-zinc-900/20 w-full inline-block px-2 py-1">Turbo Streams</a></li>
                <li><a href="/docs/broadcasting" class=" transition hover:bg-zinc-900/20 w-full inline-block px-2 py-1">Broadcasting</a></li>
                <li><a href="/docs/validation-response-redirects" class=" transition hover:bg-zinc-900/20 w-full inline-block px-2 py-1">Validation Redirects</a></li>
                <li><a href="/docs/csrf" class=" transition hover:bg-zinc-900/20 w-full inline-block px-2 py-1">CSRF Protection</a></li>
                <li><a href="/docs/hotwire-native" class=" transition hover:bg-zinc-900/20 w-full inline-block px-2 py-1">Hotwire Native</a></li>
                <li><a href="/docs/testing" class=" transition hover:bg-zinc-900/20 w-full inline-block px-2 py-1">Testing</a></li>
                <li><a href="/docs/known-issues" class=" transition hover:bg-zinc-900/20 w-full inline-block px-2 py-1">Known Issues</a></li>
              </ul>
    </li>
      </ul>
</div>
              </li>
              <li>
                <a href="https://github.com/hotwired-laravel/turbo-laravel" class="px-4 py-2 font-medium rounded-full transition hover:bg-zinc-900/20">Source Code</a>
              </li>
              <li class="space-y-6">
                <a href="/bootcamp/introduction" class="px-4 py-2 font-medium rounded-full transition hover:bg-white/90">Bootcamp</a>
                              </li>
              <!-- <li><a href="/demo" class="px-4 py-2 font-medium rounded-full transition hover:bg-white/90">Demo</a></li> -->
            </ul>
          </div>
        </div>
      </details>
    </nav>
  </div>

  <nav class="hidden lg:block">
    <ul class="flex items-center space-x-6 -my-2">
      <li>
        <div class="group relative py-2">
          <a href="/docs" class="bg-white/90 px-4 py-2 font-medium rounded-full transition hover:bg-white/90 flex items-center space-x-1">
            <span>Documentation</span>

            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="size-5">
              <path stroke-linecap="round" stroke-linejoin="round" d="m19.5 8.25-7.5 7.5-7.5-7.5" />
            </svg>
          </a>

          <div class="absolute p-4 top-14 inset-x opacity-0 scale-0 -translate-y-8 transition group-hover:translate-y-0 group-hover:scale-100 group-hover:opacity-100 rounded bg-white shadow z-10">
            <ul class="space-y-1">
              <li><a href="/docs/installation" class="block px-2 py-1 bg-zinc-900/20 rounded">Version <span class="">2.2.0</span></a></li>
              <li><a href="/1.x/docs/installation" class="block px-2 py-1  rounded">Version <span class="">1.12.2</span></a></li>
            </ul>
          </div>
        </div>
      </li>
      <li><a href="https://github.com/hotwired-laravel/turbo-laravel" class="px-4 py-2 font-medium rounded-full transition hover:bg-white/90">Source Code</a></li>
      <li><a href="/bootcamp/introduction" class=" px-4 py-2 font-medium rounded-full transition hover:bg-white/90">Bootcamp</a></li>
      <!-- <li><a href="/demo" class=" px-4 py-2 font-medium rounded-full transition hover:bg-white/90">Demo</a></li> -->
    </ul>
  </nav>
</header>

          <div class="bg-white/90 custom-border px-6 py-20 sm:flex space-x-6">
    <div class="sm:flex sm:space-x-12 sm:max-w-7xl w-full mx-auto">
      <aside data-search-target="aside" class="relative w-1/4 hidden lg:block">
        <div class="sticky top-4 block space-y-4">
            <form action="/docs/search" method="GET">
  <label for="search" class="sr-only">Search</label>
  <input data-search-target="web" type="text" name="q" placeholder="Search v2 docs... (press &quot;/&quot; to focus)" class="search-input rounded border border-zinc-900/5 px-4 py-2 text-base leading-3 shadow w-full" />
</form>

            <ul class="[&_.children]:mb-4 text-base">
    <li class="px-2 py-1 font-heading font-extrabold uppercase text-zinc-900/40">Prologue</li>
  <li class="children mt-2">
    <ul class="list-inside space-y-1">
            <li><a href="/docs/upgrade" class=" transition hover:bg-zinc-900/20 w-full inline-block px-2 py-1 rounded">Upgrade Guide</a></li>
          </ul>
  </li>
    <li class="px-2 py-1 font-heading font-extrabold uppercase text-zinc-900/40">Getting Started</li>
  <li class="children mt-2">
    <ul class="list-inside space-y-1">
            <li><a href="/docs/installation" class=" transition hover:bg-zinc-900/20 w-full inline-block px-2 py-1 rounded">Installation</a></li>
            <li><a href="/docs/overview" class=" transition hover:bg-zinc-900/20 w-full inline-block px-2 py-1 rounded">Overview</a></li>
            <li><a href="/docs/conventions" class=" transition hover:bg-zinc-900/20 w-full inline-block px-2 py-1 rounded">Conventions</a></li>
          </ul>
  </li>
    <li class="px-2 py-1 font-heading font-extrabold uppercase text-zinc-900/40">Essentials</li>
  <li class="children mt-2">
    <ul class="list-inside space-y-1">
            <li><a href="/docs/helpers" class=" transition hover:bg-zinc-900/20 w-full inline-block px-2 py-1 rounded">Helpers</a></li>
            <li><a href="/docs/turbo-frames" class=" transition hover:bg-zinc-900/20 w-full inline-block px-2 py-1 rounded">Turbo Frames</a></li>
            <li><a href="/docs/turbo-streams" class=" transition hover:bg-zinc-900/20 w-full inline-block px-2 py-1 rounded">Turbo Streams</a></li>
            <li><a href="/docs/broadcasting" class=" transition hover:bg-zinc-900/20 w-full inline-block px-2 py-1 rounded">Broadcasting</a></li>
            <li><a href="/docs/validation-response-redirects" class=" transition hover:bg-zinc-900/20 w-full inline-block px-2 py-1 rounded">Validation Redirects</a></li>
            <li><a href="/docs/csrf" class=" transition hover:bg-zinc-900/20 w-full inline-block px-2 py-1 rounded">CSRF Protection</a></li>
            <li><a href="/docs/hotwire-native" class=" transition hover:bg-zinc-900/20 w-full inline-block px-2 py-1 rounded">Hotwire Native</a></li>
            <li><a href="/docs/testing" class=" transition hover:bg-zinc-900/20 w-full inline-block px-2 py-1 rounded">Testing</a></li>
            <li><a href="/docs/known-issues" class=" transition hover:bg-zinc-900/20 w-full inline-block px-2 py-1 rounded">Known Issues</a></li>
          </ul>
  </li>
  </ul>
        </div>
      </aside>

      <main class="flex-1 min-w-0 max-w-3xl">
        <div class="prose prose-lg overflow-hidden prose-zinc [&_code:not(pre_code)]:text-wrap [&_code:not(pre_code)]:break-words prose-headings:font-heading prose-headings:font-extrabold max-w-none w-full">
              <h2>Search results for <em id="search-term" class="text-zinc-900/40"></em></h2>

  <div id="search-results"></div>

  <script>
  window.store = {
          "upgrade-guide": {
        "title": "Upgrade Guide",
        "content": "&quot;Upgrading from 1.x to 2.x\n\nFor version 2.x, we&#039;re migrating from hotwired\/turbo-laravel to hotwired-laravel\/turbo-laravel. That&#039;s just so folks don&#039;t get confused thinking this is an official Hotwired project, which it&#039;s not. Even if you&#039;re on 1.x, it&#039;s recommended to migrate to hotwired-laravel\/turbo-laravel.\n\nFirst, update the namespaces from the previous package. You can either do it from your IDE by searching for Tonysm\\TurboLaravel and replacing it with HotwiredLaravel\\TurboLaravel on your application (make sure you include all folders), or you can run the following command if you&#039;re on a macOS or Linux machine:\n\nfind app config resources tests -type f -exec sed -i &#039;s\/Tonysm\\\\TurboLaravel\/HotwiredLaravel\\\\TurboLaravel\/g&#039; {} +\n\n\nNext, update your views referencing the old components as &amp;lt;x-turbo-* to the new format which is &amp;lt;x-turbo::*. This command should be enough:\n\nfind app resources tests -type f -exec sed -i &#039;s\/x-turbo-\/x-turbo::\/g&#039; {} +\n\n\nThen, require the new package and remove the previous one:\n\ncomposer require hotwired-laravel\/turbo-laravel:^2.0\n\ncomposer remove hotwired\/turbo-laravel&quot;",
        "url": "https://turbo-laravel.com/docs/upgrade",
      },
          "installation": {
        "title": "Installation",
        "content": "&quot;Turbo Laravel can be installed via Composer:\n\ncomposer require hotwired-laravel\/turbo-laravel\n\n\nAfter installing the package, you may run the turbo:install Artisan command:\n\nphp artisan turbo:install\n\n\nThis will add the Turbo.js dependency to your package.json file, when you&#039;re using Vite and NPM, or to your routes\/importmap.php file, when it detects that you&#039;re using Importmap Laravel. It also publishes some files to your resources\/js folder, which imports Turbo for you\n\nNote: Turbo used to work with Livewire, but somewhere around Livewire V3 the bridges stopped working. There&#039;s an open issue to investigate Livewire V3 compatibility. If you&#039;re into Livewire and would love to use Turbo in a Livewire app (maybe you want to augment your Livewire &amp;amp; Turbo app with Hotwire Native or something like that), you&#039;re welcome to check out the issue and try to bring the compatibility back. If you wanted an application scaffolding like Laravel Breeze or Laravel Jetstream, checkout Turbo Breeze, our fork of Breeze that sets up a fresh Laravel app using Stimulus, Importmaps, TailwindCSS (via the CLI), and Turbo.&quot;",
        "url": "https://turbo-laravel.com/docs/installation",
      },
          "overview": {
        "title": "Overview",
        "content": "&quot;It&#039;s highly recommended that you read the Turbo Handbook first before continuing here. However, a quick intro will be provided here and we&#039;ll link to the Turbo documentations when relevant.\n\nTurbo is the heart of Hotwire. In essence, it&#039;s a JavaScript library that turns regular web applications (aka. multi-page web applications) into something that feels like a single-page application (SPA).\n\nIt provides a bunch of components that allows us to build modern web applications with minimal JavaScript. It relies on sending HTML Over The Wire (hence the name), instead of JSON, which is how JavaScript-heavy web applications are built, typically consuming some sort of JSON API.\n\nWhen Turbo.js is started in the browser, it intercepts link clicks and form submissions to convert those into fetch requests (aka. AJAX) instead of letting the browser do a full page refresh. The component in Turbo that handles this behavior is called Turbo Drive.\n\nTurbo Drive will do the heavy-lifting of the SPA feel in our application. Just by turning it on, the perceived performance should be noticeable. The default behavior of Turbo will be to replace the contents of the &amp;lt;body&amp;gt; tag in our page with the one from the response it gets from the link or form submission.\n\nAdditionally, since Turbo 8, we can also instruct Turbo to morph the page instead of just replacing its contents by adding a meta tag on the pages we can it enabled:\n\n&amp;lt;meta name=&amp;quot;turbo-refresh-method&amp;quot; content=&amp;quot;morph&amp;quot;&amp;gt;\n&amp;lt;meta name=&amp;quot;turbo-refresh-scroll&amp;quot; content=&amp;quot;preserve&amp;quot;&amp;gt;\n\n\nAlternatively, Turbo Laravel provides some Blade components to make it easier (and autocomplete friendlier) to interact with these Turbo page configurations:\n\n&amp;lt;x-turbo::refreshes-with method=&amp;quot;morph&amp;quot; scroll=&amp;quot;preserve&amp;quot; \/&amp;gt;\n\n\nTurbo Drive does a lot for us, and with morphing it gets even more powerful, but sometimes you can want to decompose a page into independent sections (for different reasons, such as having more control over HTTP caching for these sections). For these use cases, Turbo offers Turbo Frames.\n\nTurbo Frames are custom HTML tags that Turbo provides. You can think of those as \&quot;modern iframes\&quot;, if you will. When link clicks or form submissions happen inside of a Turbo Frame, instead of replacing or morphing the entire page, Turbo will only affect that specific Turbo Frame&#039;s content. It will do so by extracting a matching Turbo Frame (one that has the same DOM ID) on the response.\n\nHere&#039;s how you can use Turbo Frames:\n\n&amp;lt;turbo-frame id=&amp;quot;my_frame&amp;quot;&amp;gt;\n    &amp;lt;h1&amp;gt;Hello, World!&amp;lt;\/h1&amp;gt;\n\n    &amp;lt;a href=&amp;quot;\/somewhere&amp;quot;&amp;gt;Click me&amp;lt;\/a&amp;gt;\n&amp;lt;\/turbo-frame&amp;gt;\n\n\nAlternatively, you may want a Turbo Frame to immediately fetch its contents instead of waiting for a user interaction. For that, you may add a [src] attribute to the Turbo Frame tag with the URL of where Turbo should fetch that content from. This technique is called Lazy-loading Turbo Frames:\n\n&amp;lt;turbo-frame id=&amp;quot;my_frame&amp;quot; src=&amp;quot;@{{ route(&#039;my.page&#039;) }}&amp;quot;&amp;gt;\n    &amp;lt;p&amp;gt;Loading...&amp;lt;\/p&amp;gt;\n&amp;lt;\/turbo-frame&amp;gt;\n\n\nA lazy-loaded Turbo Frame will dispatch a fetch request (aka. AJAX) as soon as it enters the DOM, replacing its contents with the contents of a matching Turbo Frame in the response HTML. Optionally, you may add a [loading=lazy] attribute to the lazy-loaded Turbo Frame so Turbo will only fetch its content when the Turbo Frame is visible (within the viewport):\n\n&amp;lt;turbo-frame id=&amp;quot;my_frame&amp;quot; src=&amp;quot;@{{ route(&#039;my.page&#039;) }}&amp;quot; loading=&amp;quot;lazy&amp;quot;&amp;gt;\n    &amp;lt;p&amp;gt;Loading...&amp;lt;\/p&amp;gt;\n&amp;lt;\/turbo-frame&amp;gt;\n\n\nYou may also trigger a Turbo Frame with forms and links that are outside of the frame tag by adding a [data-turbo-frame] attribute in the link, form, or submit buttons, passing the ID of the Turbo Frame:\n\n&amp;lt;div&amp;gt;\n    &amp;lt;a href=&amp;quot;\/somewhere&amp;quot; data-turbo-frame=&amp;quot;my_frame&amp;quot;&amp;gt;I&#039;m a link&amp;lt;\/a&amp;gt;\n\n    &amp;lt;turbo-frame id=&amp;quot;my_frame&amp;quot;&amp;gt;\n        ...\n    &amp;lt;\/turbo-frame&amp;gt;\n&amp;lt;\/div&amp;gt;\n\n\nTurbo Drive and Turbo Frames allows us to build A LOT of different sorts of interactions. However, sometimes you may want to update multiple sections of a page after a form submission, for instance. For those use cases, Turbo provides another custom HTML tag called Turbo Streams.\n\nAll link clicks and form submissions that Turbo intercepts are annotated by Turbo, which tells our back-end application that Turbo is on, so we can return a special type of response that only contains Turbo Streams. Turbo.js will do so by adding a custom MIME type of text\/vnd.turbo-stream.html to the Accept HTTP Header.\n\nTurbo Streams allows for a more fine-grained control over the page updates. For instance, here&#039;s an example of a Turbro Stream that appends a new comment to a comments section:\n\n&amp;lt;turbo-stream action=&amp;quot;append&amp;quot; target=&amp;quot;comments&amp;quot;&amp;gt;\n    &amp;lt;template&amp;gt;\n        ...\n    &amp;lt;\/template&amp;gt;\n&amp;lt;\/turbo-stream&amp;gt;\n\n\nThe [action=append] will add the contents of what&#039;s inside the &amp;lt;template&amp;gt;&amp;lt;\/template&amp;gt; tag into the element that has a DOM ID matching the [target=comments] attribute, so #comments in this case.\n\nThere are 8 default Turbo Stream actions in Turbo:\n\n\n\n\n  Action\n  Description\n\n\n\n\n  append\n  Appends the contents of the &amp;lt;template&amp;gt; tag into the target or targets\n\n\n  prepend\n  Prepends the contents of the &amp;lt;template&amp;gt; tag to the target or targets\n\n\n  update\n  Updates the target or targets with the contents of the &amp;lt;template&amp;gt; tag (keeps the targeted elements around)\n\n\n  replace\n  Replaces the target or targets with the contents of the &amp;lt;template&amp;gt; tag (actually removes the targets)\n\n\n  before\n  Inserts the contents of the &amp;lt;template&amp;gt; tag before the targeted elements\n\n\n  after\n  Inserts the contents of the &amp;lt;template&amp;gt; tag after the targeted elements\n\n\n  remove\n  Removes the targeted elements (doesn&#039;t require a &amp;lt;template&amp;gt; tag)\n\n\n  refresh\n  Signals to Turbo Drive to do a page refresh (doesn&#039;t require a &amp;lt;template&amp;gt; tag, nor \&quot;target\&quot;)\n\n\n\n\nAll the default Turbo Stream actions, except the refresh one, require a target or a targets attribute. The difference here is that if you use the target attribute, it expects a DOM ID of the target element, and if you use the targets attribute, it expects a CSS selector of the target(s) element(s).\n\nAll of the default actions require the contents of the new or updated element to be wrapped inside a &amp;lt;template&amp;gt; tag, except for the remove and refresh actions. That&#039;s because Turbo Stream tags can be activated by simply adding them to the document. They&#039;ll get activate based on the action and then get removed from the DOM. Having the &amp;lt;template&amp;gt; ensure the content is not visible in the browser as it gets activated.\n\nI keep saying \&quot;default action\&quot;, well, that&#039;s because Turbo allows us to create our own custom actions:\n\nimport { StreamActions } from &amp;quot;{{&#039;@&#039;}}hotwired\/turbo&amp;quot;\n\nStreamActions.log = function () {\n  console.log(this.getAttribute(&amp;quot;message&amp;quot;))\n}\n\n\nIn this case, we can use this action like so:\n\n&amp;lt;turbo-stream action=&amp;quot;log&amp;quot; message=&amp;quot;Hello World&amp;quot;&amp;gt;&amp;lt;\/turbo-stream&amp;gt;\n\n\nThis will get \&quot;Hello World\&quot; printed on the DevTools Console. With custom actions, you can do pretty much anything on the document.\n\nSo far, all vanilla Hotwire and Turbo.&quot;",
        "url": "https://turbo-laravel.com/docs/overview",
      },
          "conventions": {
        "title": "Conventions",
        "content": "&quot;The conventions described below are NOT mandatory. Feel free to pick what you like and also come up with your own conventions. With that out of the way, here&#039;s a list of conventions you may find helpful.\n\nResource Routes\n\nLaravel supports resource routes and that plays really well with Hotwire for most things. This creates route names such as posts.index, posts.store, etc.\n\nIf you don&#039;t want to use resource routes, at least consider using the naming convention: render forms in route names ending in .create, .edit, or .delete, and name their handler routes ending with .store, .update, or .destroy, accordingly.\n\nTurbo Laravel uses this naming convention so it doesn&#039;t redirect after failed validations and, instead, triggers another internal request to the application as well so it can re-render the form returning a 422 response with. The form should re-render with the old() input values and any validation messages as well.\n\nYou may want to define exceptions to the route guessing behavior. In that&#039;s the case, set them in the redirect_guessing_exceptions in the config\/turbo-laravel.php config file:\n\nreturn [\n    \/\/ ...\n    &#039;redirect_guessing_exceptions&#039; =&amp;gt; [\n        &#039;\/some-page&#039;,\n    ],\n];\n\n\nWhen using this config, the redirection behavior will still happen, but the package will not attempt to guess the routes that render the forms on those routes. See the Validation Response Redirects page to know more about why this happens.\n\nPartials\n\nYou may want to split up your views in smaller chunks (aka. \&quot;partials\&quot;), such as a comments\/_comment.blade.php to display a comment resource, or comments\/_form.blade.php to display the form for both creating and updating comments. This allows you to reuse these partials in Turbo Streams.\n\nAlternatively, you may override the pattern to a {plural}.partials.{singular} convention for your partials location by calling the Turbo::usePartialsSubfolderPattern() method of the Turbo Facade from your AppServiceProvider::boot() method:\n\n&amp;lt;?php\n\nnamespace App\\Providers;\n\nuse HotwiredLaravel\\TurboLaravel\\Facades\\Turbo;\nuse Illuminate\\Support\\ServiceProvider;\n\nclass AppServiceProvider extends ServiceProvider\n{\n    public function boot()\n    {\n        Turbo::usePartialsSubfolderPattern();\n    }\n}\n\n\nYou may also want to define your own pattern for partials, which you can do using the Turbo::resolvePartialsUsing() method. This method accepts either a string pattern or a Closure. If you pass a string pattern, you&#039;ll have two placeholders available: {singular} and {plural}, which will get replaced with the model&#039;s singular and plural names, respectively, when the pattern is used. If you pass a Closure, you&#039;ll have the model instance available and you must return the view pattern using Laravel&#039;s dot notation convention. The pattern returned from the Closure will also get the placeholders applied, if you need that. Here&#039;s how you could manually define the partials subfolder pattern:\n\n&amp;lt;?php\n\nnamespace App\\Providers;\n\nuse HotwiredLaravel\\TurboLaravel\\Facades\\Turbo;\nuse Illuminate\\Support\\ServiceProvider;\n\nclass AppServiceProvider extends ServiceProvider\n{\n    public function boot()\n    {\n        Turbo::resolvePartialsPathUsing(&#039;{plural}.partials.{singular}&#039;);\n\n        \/\/ Or...\n\n        Turbo::resolvePartialsPathUsing(fn ($model) =&amp;gt; &#039;partials.{singular}&#039;);\n    }\n}\n\n\nYou may also want to define your own pattern, which you can do by either specifying a string where you have the {plural} and {singular} placeholders available, but you can also specify a Closure, which will receive the model instance. On that Closure, you must return a string with the view location using the dot convention of Laravel. For instance, the subfolder pattern sets the config value to {plural}.partials.{singular} instead of the default, which is {plural}._{singular}. These will resolve to comments.partials.comment and comments._comment views, respectively.\n\nThe models&#039; partials (such as a comments\/_comment.blade.php for a Comment model) may only rely on having a single $comment variable passed to them. That&#039;s because Turbo Stream Model Broadcasts - which is an optional feature, by the way - relies on these conventions to figure out the partial for a given model when broadcasting and will also pass the model to such partial, using the class basename as the variable instance in camelCase. Again, this is optional, you can customize most of these things or create your own model broadcasting convention. Read the Broadcasting section to know more.\n\nTurbo Stream Channel Names\n\nNote: Turbo Stream Broadcasts are optional.\n\nYou may use the model&#039;s Fully Qualified Class Name (aka. FQCN) as your Broadcasting Channel authorization routes with a wildcard, such as App.Models.Comment.{comment} for a Comment model living in App\\\\Models\\\\ - the wildcard&#039;s name doesn&#039;t matter, as long as there is one. This is the default broadcasting channel naming convention in Laravel.&quot;",
        "url": "https://turbo-laravel.com/docs/conventions",
      },
          "helpers": {
        "title": "Helpers",
        "content": "&quot;Turbo Laravel has a set of Blade Directives, Components, helper functions, and request\/response macros to help making the most out of Turbo in Laravel.\n\nBlade Directives\n\nThe @domid() Blade Directive\n\nSince Turbo relies a lot on DOM IDs, the package offers a helper to generate unique DOM IDs based on your models. You may use the @domid Blade Directive in your Blade views like so:\n\n&amp;lt;turbo-frame id=&amp;quot;{{&#039;@&#039;}}domid($post)&amp;quot;&amp;gt;\n    &amp;lt;!-- Content --&amp;gt;\n&amp;lt;\/turbo-frame&amp;gt;\n\n\nThis will generate a DOM ID string using your model&#039;s basename and its ID, such as post_123. You may also give it a prefix that will be added to the DOM ID, such as:\n\n&amp;lt;turbo-frame id=&amp;quot;{{&#039;@&#039;}}domid($post, &#039;comments&#039;)&amp;quot;&amp;gt;\n    &amp;lt;!-- Comments --&amp;gt;\n&amp;lt;\/turbo-frame&amp;gt;\n\n\nWhich will generate a comments_post_123 DOM ID, assuming your Post model has an ID of 123.\n\nBlade Components\n\nThe &amp;lt;x-turbo::frame&amp;gt; Blade Component\n\nYou may also prefer using the &amp;lt;x-turbo::frame&amp;gt; Blade component that ships with the package. This way, you don&#039;t need to worry about using the @domid() helper for your Turbo Frame:\n\n&amp;lt;x-turbo::frame :id=&amp;quot;$post&amp;quot;&amp;gt;\n    &amp;lt;!-- Content --&amp;gt;\n&amp;lt;\/x-turbo::frame&amp;gt;\n\n\nTo the :id prop, you may pass a string, which will be used as-is as the DOM ID, an Eloquent model instance, which will be passed to the dom_id() function that ships with the package (the same one as the @domid() Blade directive uses behind the scenes), or an array tuple where the first item is an instance of an Eloquent model and the second is the prefix of the DOM ID, something like this:\n\n&amp;lt;x-turbo::frame :id=&amp;quot;[$post, &#039;comments&#039;]&amp;quot;&amp;gt;\n    &amp;lt;!-- Comments --&amp;gt;\n&amp;lt;\/x-turbo::frame&amp;gt;\n\n\nAdditionally, you may also pass along any prop that is supported by the Turbo Frame custom Element to the &amp;lt;x-turbo::frame&amp;gt; Blade component, like target, src, or loading. These are the listed attributes, but any other attribute will also be forwarded to the &amp;lt;turbo-frame&amp;gt; tag that will be rendered by the &amp;lt;x-turbo::frame&amp;gt; component. For a full list of what&#039;s possible to do with Turbo Frames, see the documentation.\n\nThe &amp;lt;x-turbo::stream&amp;gt; Blade Component\n\nIf you&#039;re rendering a Turbo Stream inside a your Blade files, you may use the &amp;lt;x-turbo::stream&amp;gt; helper:\n\n&amp;lt;x-turbo::stream :target=&amp;quot;$post&amp;quot; action=&amp;quot;update&amp;quot;&amp;gt;\n    {{&#039;@&#039;}}include(&#039;posts.partials.post&#039;, [&#039;post&#039; =&amp;gt; $post])\n&amp;lt;x-turbo::stream&amp;gt;\n\n\nJust like in the Turbo Frames&#039; :id prop, the :target prop of the Turbo Stream component accepts a string, a model instance, or an array to resolve the DOM ID using the dom_id() function.\n\nThe &amp;lt;x-turbo::refresh-method method=\&quot;morph\&quot; \/&amp;gt; Blade Component\n\nWe can configure which update method Turbo should so to update the document:\n\n\n\n\n  Method\n  Description\n\n\n\n\n  replace\n  Updates the entire body of the document on Turbo Visits\n\n\n  morph\n  Uses DOM morphing to update the document instead of replacing everything\n\n\n\n\nHere&#039;s how you can use it:\n\n&amp;lt;x-turbo::refresh-method method=&amp;quot;morph&amp;quot; \/&amp;gt;\n\n\nThe output would be:\n\n&amp;lt;meta name=&amp;quot;turbo-refresh-method&amp;quot; content=&amp;quot;morph&amp;quot;&amp;gt;\n\n\nThe &amp;lt;x-turbo::refresh-scroll scroll=\&quot;preserve\&quot; \/&amp;gt; Blade Component\n\nYou can also configure the scroll behavior on Turbo:\n\n\n\n\n  Behavior\n  Description\n\n\n\n\n  reset\n  Resets the scroll position to the top, mimicking for the browser handles new page visits\n\n\n  preserve\n  Preserves the current scroll position (usually results in a better UX when used with the morph method)\n\n\n\n\nHere&#039;s how you can use it:\n\n&amp;lt;x-turbo::refresh-scroll scroll=&amp;quot;preserve&amp;quot; \/&amp;gt;\n\n\nThe output would be:\n\n&amp;lt;meta name=&amp;quot;turbo-refresh-scroll&amp;quot; content=&amp;quot;preserve&amp;quot;&amp;gt;\n\n\nThe &amp;lt;x-turbo::refreshes-with&amp;gt; Blade Component\n\nYou may configure both the refresh method and scroll behavior using the &amp;lt;x-turbo::refreshes-with \/&amp;gt; component in your main layout&#039;s &amp;lt;head&amp;gt; tag or on specific pages to configure how Turbo should update the page. Here&#039;s an example:\n\n&amp;lt;x-turbo::refreshes-with method=&amp;quot;morph&amp;quot; scroll=&amp;quot;preserve&amp;quot; \/&amp;gt;\n\n\nThis will render two HTML &amp;lt;meta&amp;gt; tags:\n\n&amp;lt;meta name=&amp;quot;turbo-refresh-method&amp;quot; content=&amp;quot;morph&amp;quot;&amp;gt;\n&amp;lt;meta name=&amp;quot;turbo-refresh-scroll&amp;quot; content=&amp;quot;preserve&amp;quot;&amp;gt;\n\n\nThe &amp;lt;x-turbo::exempts-page-from-cache \/&amp;gt; Blade Component\n\nThis component may be added to any page you don&#039;t want Turbo to keep a cache in the page cache. Example:\n\n&amp;lt;x-turbo::exempts-page-from-cache \/&amp;gt;\n\n\nIt will render the HTML &amp;lt;meta&amp;gt; tag:\n\n&amp;lt;meta name=&amp;quot;turbo-cache-control&amp;quot; content=&amp;quot;no-cache&amp;quot;&amp;gt;\n\n\nThe &amp;lt;x-turbo::exempts-page-from-preview \/&amp;gt; Blade Component\n\nThis component may be added to any page you don&#039;t want Turbo to show as a preview on regular navigation visits. No-preview pages will only be used in restoration visits (when you use the browser&#039;s back or forward buttons, or when when moving backward in the navigation stack). Example:\n\n&amp;lt;x-turbo::exempts-page-from-preview \/&amp;gt;\n\n\nIt will render the HTML &amp;lt;meta&amp;gt; tag:\n\n&amp;lt;meta name=&amp;quot;turbo-cache-control&amp;quot; content=&amp;quot;no-preview&amp;quot;&amp;gt;\n\n\nThe &amp;lt;x-turbo::page-requires-reload \/&amp;gt; Blade Component\n\nThis component may be added to any page you want Turbo to reload. This will break out of Turbo Frame navigations. May be used at a login screen, for instance. Example:\n\n&amp;lt;x-turbo::page-requires-reload \/&amp;gt;\n\n\nIt will render the HTML &amp;lt;meta&amp;gt; tag:\n\n&amp;lt;meta name=&amp;quot;turbo-visit-control&amp;quot; content=&amp;quot;reload&amp;quot;&amp;gt;\n\n\nHelper Functions\n\nThe package ships with a set of helper functions. These functions are all namespaced under HotwiredLaravel\\\\TurboLaravel\\\\ but we also add them globally for convenience, so you may use them directly without the use statements (this is useful in contexts like Blade views, for instance).\n\nThe dom_id()\n\nThe mentioned namespaced dom_id() helper function may also be used from anywhere in your application, like so:\n\nuse function HotwiredLaravel\\TurboLaravel\\dom_id;\n\ndom_id($comment);\n\n\nWhen a new instance of a model is passed to any of these DOM ID helpers, since it doesn&#039;t have an ID, it will prefix the resource name with a create_ prefix. This way, new instances of an App\\\\Models\\\\Comment model will generate a create_comment DOM ID.\n\nThese helpers strip out the model&#039;s FQCN (see config\/turbo-laravel.php if you use an unconventional location for your models).\n\nThe dom_class()\n\nThe dom_class() helper function may be used from anywhere in your application, like so:\n\nuse function HotwiredLaravel\\TurboLaravel\\dom_class;\n\ndom_class($comment);\n\n\nThis function will generate the DOM class named based on your model&#039;s class name. If you have an instance of a App\\Models\\Comment model, it will generate a comment DOM class.\n\nSimilarly to the dom_id() function, you may also pass a context prefix as the second parameter:\n\ndom_class($comment, &#039;reactions_list&#039;);\n\n\nThis will generate a DOM class of reactions_list_comment.\n\nThe turbo_stream()\n\nYou may generate Turbo Streams using the Response::turboStream() macro, but you may also do so using the turbo_stream() helper function:\n\nuse function HotwiredLaravel\\TurboLaravel\\turbo_stream;\n\nturbo_stream()-&amp;gt;append($comment);\n\n\nBoth the Response::turboStream() and the turbo_stream() function work the same way. The turbo_stream() function may be easier to use.\n\nThe turbo_stream_view()\n\nYou may combo Turbo Streams using the turbo_stream([]) function passing an array, but you may prefer to create a separate Blade view with all the Turbo Streams, this way you may also use template extensions and everything else Blade offers:\n\nuse function HotwiredLaravel\\TurboLaravel\\turbo_stream_view;\n\nreturn turbo_stream_view(&#039;comments.turbo.created&#039;, [\n    &#039;comment&#039; =&amp;gt; $comment,\n]);\n\n\nRequest &amp;amp; Response Macros\n\nThe request()-&amp;gt;wantsTurboStream() macro\n\nThe request()-&amp;gt;wantsTurboStream() macro added to the request class will check if the request accepts Turbo Stream and return true or false accordingly.\n\nTurbo will add a Accept: text\/vnd.turbo-stream.html, ... header to the requests. That&#039;s how we can detect if the request came from a client using Turbo.\n\nThe request()-&amp;gt;wasFromTurboFrame() macro\n\nThe request()-&amp;gt;wasFromTurboFrame() macro added to the request class will check if the request was made from a Turbo Frame. When used with no parameters, it returns true if the request has a Turbo-Frame header, no matter which specific Turbo Frame.\n\nAdditionally, you may specific the optional $frame parameter. When that&#039;s passed, it returns true if it has a Turbo-Frame header where the value matches the specified $frame. Otherwise, it will return false:\n\nif (request()-&amp;gt;wasFromTurboFrame(dom_id($post, &#039;create_comment&#039;))) {\n    \/\/ ...\n}\n\n\nThe request()-&amp;gt;wasFromHotwireNative() macro\n\nThe request()-&amp;gt;wasFromHotwireNative() macro added to the request class will check if the request came from a Hotwire Native client and returns true or false accordingly.\n\nHotwire Native clients are encouraged to override the User-Agent header in the WebViews to mention the words Hotwire Native on them. This is what this macro uses to detect if it came from a Hotwire Native client.\n\nThe response()-&amp;gt;turboStream() macro\n\nThe response()-&amp;gt;turboStream() macro works similarly to the turbo_stream() function above. It was only added to the response for convenience.\n\nThe response()-&amp;gt;turboStreamView() macro\n\nThe response()-&amp;gt;turboStreamView() macro works similarly to the turbo_stream_view() function above. It was only added to the response for convenience.&quot;",
        "url": "https://turbo-laravel.com/docs/helpers",
      },
          "turbo-frames": {
        "title": "Turbo Frames",
        "content": "&quot;The Turbo Frame tag that ships with Turbo can be used on your Blade views just like any other HTML tag:\n\n&amp;lt;turbo-frame id=&amp;quot;{{&#039;@&#039;}}domid($post, &#039;create_comment&#039;)&amp;quot;&amp;gt;\n    &amp;lt;p&amp;gt;Loading...&amp;lt;\/p&amp;gt;\n&amp;lt;\/turbo-frame&amp;gt;\n\n\nIn this case, the @domid() directive is being used to create a DOM ID that looks like this create_comment_post_123. There&#039;s also a Blade Component that ships with Turbo Laravel and can be used like this:\n\n&amp;lt;x-turbo::frame :id=&amp;quot;[$post, &#039;create_comment&#039;]&amp;quot;&amp;gt;\n    &amp;lt;p&amp;gt;Loading...&amp;lt;\/p&amp;gt;\n&amp;lt;\/x-turbo::frame&amp;gt;\n\n\nWhen using the Blade Component, you don&#039;t have to worry about using the @domid() directive or the dom_id() function, as this gets handled automatically by the package. You may also pass a string if you want to enforce your own DOM ID.\n\nAny other attribute passed to the Blade Component will get forwarded to the underlying &amp;lt;turbo-frame&amp;gt; element, so if you want to turn a Turbo Frame into a lazy-loading Turbo Frame using the Blade Component, you can do it like so:\n\n&amp;lt;x-turbo::frame\n    :id=&amp;quot;[$post, &#039;create_comment&#039;]&amp;quot;\n    :src=&amp;quot;route(&#039;post.comments.create&#039;, $post)&amp;quot;\n    loading=&amp;quot;lazy&amp;quot;\n&amp;gt;\n    &amp;lt;p&amp;gt;Loading...&amp;lt;\/p&amp;gt;\n&amp;lt;\/x-turbo::frame&amp;gt;\n\n\nThis will work for any other attribute you want to forward to the underlying component.\n\nThe request()-&amp;gt;wasFromTurboFrame() Macro\n\nYou may want to detect if a request came from a Turbo Frame in the backend. You may use the wasFromTurboFrame() method for that:\n\nif ($request-&amp;gt;wasFromTurboFrame()) {\n    \/\/ ...\n}\n\n\nWhen used like this, the macro will return true if the X-Turbo-Frame custom HTTP header is present in the request (which Turbo adds automatically), or false otherwise.\n\nYou may also check if the request came from a specific Turbo Frame:\n\nif ($request-&amp;gt;wasFromTurboFrame(dom_id($post, &#039;create_comment&#039;))) {\n    \/\/ ...\n}&quot;",
        "url": "https://turbo-laravel.com/docs/turbo-frames",
      },
          "turbo-streams": {
        "title": "Turbo Streams",
        "content": "&quot;Out of everything Turbo provides, it&#039;s Turbo Streams that benefits the most from a tight backend integration.\n\nTurbo Laravel offers helper functions, Blade Components, and Model traits to generate Turbo Streams. Turbo will add a new Content-Type to the HTTP Accept header (Accept: text\/vnd.turbo-stream.html, ...) on Form submissions. This is a signal to the backend that we can return a Turbo Stream response for that form submission instead of an HTML document, if we want to.\n\nHere&#039;s an example of a route handler detecting and returning a Turbo Stream response to a form submission:\n\nRoute::post(&#039;posts\/{post}\/comments&#039;, function (Post $post) {\n    $comment = $post-&amp;gt;comments()-&amp;gt;create(\/** params *\/);\n\n    if (request()-&amp;gt;wantsTurboStream()) {\n        return turbo_stream($comment);\n    }\n\n    return back();\n});\n\n\nThe request()-&amp;gt;wantsTurboStream() macro added to the request class will check if the request accepts Turbo Stream and return true or false accordingly.\n\nThe turbo_stream() helper function may be used to generate streams, but you may also use the response()-&amp;gt;turboStream() macro as well. In the docs, we&#039;ll only use the helper function, but you may use either one of those.\n\nHere&#039;s what the HTML response will look like:\n\n&amp;lt;turbo-stream action=&amp;quot;append&amp;quot; target=&amp;quot;comments&amp;quot;&amp;gt;\n    &amp;lt;template&amp;gt;\n        &amp;lt;div id=&amp;quot;comment_123&amp;quot;&amp;gt;\n            &amp;lt;p&amp;gt;Hello, World&amp;lt;\/p&amp;gt;\n        &amp;lt;\/div&amp;gt;\n    &amp;lt;\/template&amp;gt;\n&amp;lt;\/turbo-stream&amp;gt;\n\n\nMost of these things were \&quot;guessed\&quot; based on the conventions we talked about earlier. But you can override most things, like so:\n\nturbo_stream($comment)-&amp;gt;target(&#039;post_comments&#039;);\n\n\nThis would render the following Turbo Stream:\n\n&amp;lt;turbo-stream action=&amp;quot;append&amp;quot; target=&amp;quot;post_comments&amp;quot;&amp;gt;\n    &amp;lt;template&amp;gt;\n        &amp;lt;div id=&amp;quot;comment_123&amp;quot;&amp;gt;\n            &amp;lt;p&amp;gt;Hello, World&amp;lt;\/p&amp;gt;\n        &amp;lt;\/div&amp;gt;\n    &amp;lt;\/template&amp;gt;\n&amp;lt;\/turbo-stream&amp;gt;\n\n\nAlthough it&#039;s handy to pass a model instance to the turbo_stream() function - which will be used to decide the default values of the Turbo Stream response based on the model&#039;s current state, sometimes you may want to build a Turbo Stream response manually:\n\nturbo_stream()\n    -&amp;gt;target(&#039;comments&#039;)\n    -&amp;gt;action(&#039;append&#039;)\n    -&amp;gt;view(&#039;comments.partials.comment&#039;, [&#039;comment&#039; =&amp;gt; $comment]);\n\n\nThere are also shorthand methods which may be used as well:\n\nturbo_stream()-&amp;gt;append($comment);\nturbo_stream()-&amp;gt;prepend($comment);\nturbo_stream()-&amp;gt;before($comment);\nturbo_stream()-&amp;gt;after($comment);\nturbo_stream()-&amp;gt;replace($comment);\nturbo_stream()-&amp;gt;update($comment);\nturbo_stream()-&amp;gt;remove($comment);\nturbo_stream()-&amp;gt;refresh();\n\n\nYou may pass an instance of an Eloquent model to all these shorthand methods, except the refresh one, which will be used to figure things out like target, the view, and will also pass that model instance to the view.\n\nFor a model App\\Models\\Comment, the convention says that the view is located at resources\/views\/comments\/_comment.blade.php. Based on the model&#039;s class basename, it will figure out the name of the variable that the view should depend on, which would be $comment in this case, so it would pass the model instance down to the view automatically. For that reason, when using the convention (which is optional), the model view must only depend on the model instance to be available (no globals or other locals with no defaults).\n\nAlternatively, you may also pass strings to the shorthand stream builders, which will be used as the target, and an optional content string, which will be rendered instead of a partial, for instance:\n\nturbo_stream()-&amp;gt;append(&#039;statuses&#039;, __(&#039;Comment created!&#039;));\n\n\nThe optional content parameter expects either a string, a view instance, or an instance of Laravel&#039;s Illuminate\\Support\\HtmlString, so you could do something like:\n\nturbo_stream()-&amp;gt;append(&#039;some_dom_id&#039;, view(&#039;greetings&#039;, [\n    &#039;name&#039; =&amp;gt; &#039;Tester&#039;,\n]));\n\n\nOr more explicitly by passing an instance of the HtmlString as content:\n\nuse Illuminate\\Support\\Facades\\Blade;\nuse Illuminate\\Support\\HtmlString;\n\nturbo_stream()-&amp;gt;append(&#039;statuses&#039;, new HtmlString(\n    Blade::render(&#039;&amp;lt;div&amp;gt;Hello, @{{ $name }}&amp;lt;\/div&amp;gt;&#039;, [&#039;name&#039; =&amp;gt; &#039;Tony&#039;])\n));\n\n\nWhich will result in a Turbo Stream like this:\n\n&amp;lt;turbo-stream target=&amp;quot;statuses&amp;quot; action=&amp;quot;append&amp;quot;&amp;gt;\n    &amp;lt;template&amp;gt;\n        &amp;lt;div&amp;gt;Hello, Tony&amp;lt;\/div&amp;gt;\n    &amp;lt;\/template&amp;gt;\n&amp;lt;\/turbo-stream&amp;gt;\n\n\nFor both the before and after methods you need additional calls to specify the view template you want to insert, since the given model\/string will only be used to specify the target, something like:\n\nturbo_stream()\n    -&amp;gt;before($comment)\n    -&amp;gt;view(&#039;comments.partials.flash_message&#039;, [\n        &#039;message&#039; =&amp;gt; __(&#039;Comment created!&#039;),\n    ]);\n\n\nJust like the other shorthand stream builders, you may also pass an option content string or HtmlString instance to the before and after shorthands. When doing that, you don&#039;t need to specify the view section.\n\nturbo_stream()-&amp;gt;before($comment, __(&#039;Oh, hey!&#039;));\n\n\nYou can read more about Turbo Streams in the Turbo Handbook.\n\nAs mentioned earlier, passing a model to the turbo_stream() helper (or the shorthand Turbo Stream builders) will pre-fill the pending response object with some defaults based on the model&#039;s state.\n\nIt will build a remove Turbo Stream if the model was just deleted (or if it was trashed - in case it&#039;s a Soft Deleted model), an append if the model was recently created (which you can override the action as the second parameter), a replace if the model was just updated (you can also change it to update using the second parameter.) Here&#039;s how overriding would look like:\n\nreturn turbo_stream($comment, &#039;append&#039;);\n\n\nTurbo Streams &amp;amp; Morph\n\nBoth the update and replace Turbo Stream actions can specify a [method=\&quot;morph\&quot;] attribute, so the action will use DOM morphing instead of the default renderer.\n\nTo generate a Turbo Stream with the [method=\&quot;morph\&quot;] attribute, chain the morph() method:\n\nturbo_stream()-&amp;gt;replace(dom_id($post, &#039;comments&#039;), view(&#039;comments.partials.comment&#039;, [\n    &#039;comment&#039; =&amp;gt; $comment,\n]))-&amp;gt;morph();\n\n\nThis would generate the following Turbo Stream HTML:\n\n&amp;lt;turbo-stream action=&amp;quot;replace&amp;quot; target=&amp;quot;comments_post_123&amp;quot; method=&amp;quot;morph&amp;quot;&amp;gt;\n    &amp;lt;template&amp;gt;...&amp;lt;\/template&amp;gt;\n&amp;lt;\/turbo-stream&amp;gt;\n\n\nAnd here&#039;s the update action version:\n\nturbo_stream()-&amp;gt;update(dom_id($post, &#039;comments&#039;), view(&#039;comments.partials.comment&#039;, [\n    &#039;comment&#039; =&amp;gt; $comment,\n]))-&amp;gt;morph();\n\n\nThis would generate the following Turbo Stream HTML:\n\n&amp;lt;turbo-stream action=&amp;quot;update&amp;quot; target=&amp;quot;comments_post_123&amp;quot; method=&amp;quot;morph&amp;quot;&amp;gt;\n    &amp;lt;template&amp;gt;...&amp;lt;\/template&amp;gt;\n&amp;lt;\/turbo-stream&amp;gt;\n\n\nTarget Multiple Elements\n\nTurbo Stream elements can either have a target with a DOM ID or a targets attribute with a CSS selector to match multiple elements. You may use the xAll shorthand methods to set the targets attribute instead of target:\n\nturbo_stream()-&amp;gt;appendAll(&#039;.comment&#039;, &#039;Some content&#039;);\nturbo_stream()-&amp;gt;prependAll(&#039;.comment&#039;, &#039;Some content&#039;);\nturbo_stream()-&amp;gt;updateAll(&#039;.comment&#039;, &#039;Some content&#039;);\nturbo_stream()-&amp;gt;replaceAll(&#039;.comment&#039;, &#039;Some content&#039;);\nturbo_stream()-&amp;gt;beforeAll(&#039;.comment&#039;, &#039;Some content&#039;);\nturbo_stream()-&amp;gt;afterAll(&#039;.comment&#039;, &#039;Some content&#039;);\nturbo_stream()-&amp;gt;removeAll(&#039;.comment&#039;);\n\n\nWith the exception of the removeAll method, the xAll methods accept a string of inline content, an instance of a View (which may be created using the view() function provided by Laravel), or an instance of the HtmlSafe class as the second parameter.\n\nWhen creating Turbo Streams using the builders, you may also specify the CSS class using the targets() (plural) method instead of the target() (singular) version:\n\nturbo_stream()\n    -&amp;gt;targets(&#039;.comment&#039;)\n    -&amp;gt;action(&#039;append&#039;)\n    -&amp;gt;view(&#039;comments.partials.comment&#039;, [&#039;comment&#039; =&amp;gt; $comment]);\n\n\nTurbo Stream Macros\n\nThe turbo_stream() function returns an instance of PendingTurboStreamResponse, which is macroable. This means you can create your own DSL for your custom Turbo Streams. Let&#039;s say you always return flash messages from your controllers like so:\n\nclass ChirpsController extends Controller\n{\n    public function destroy(Request $request, Chirp $chirp)\n    {\n        $this-&amp;gt;authorize(&#039;delete&#039;, $chirp);\n\n        $chirp-&amp;gt;delete();\n\n        if ($request-&amp;gt;wantsTurboStream()) {\n            return turbo_stream([\n                turbo_stream($chirp),\n                turbo_stream()-&amp;gt;append(&#039;notifications&#039;, view(&#039;layouts.notification&#039;, [\n                    &#039;message&#039; =&amp;gt; __(&#039;Chirp deleted.&#039;),\n                ])),\n            ]);\n        }\n\n        \/\/ ...\n    }\n}\n\n\nChances are you&#039;re gonna return flash messages from all your controllers, so you could create a custom macro like so:\n\nclass AppServiceProvider extends ServiceProvider\n{\n    public function boot()\n    {\n        PendingTurboStreamResponse::macro(&#039;flash&#039;, function (string $message) {\n            return $this-&amp;gt;append(&#039;notifications&#039;, view(&#039;layouts.notification&#039;, [\n                &#039;message&#039; =&amp;gt; $message,\n            ]));\n        });\n    }\n}\n\n\nYou could then rewrite that controller like so:\n\nclass ChirpsController extends Controller\n{\n    public function destroy(Request $request, Chirp $chirp)\n    {\n        $this-&amp;gt;authorize(&#039;delete&#039;, $chirp);\n\n        $chirp-&amp;gt;delete();\n\n        if ($request-&amp;gt;wantsTurboStream()) {\n            return turbo_stream([\n                turbo_stream($chirp),\n                turbo_stream()-&amp;gt;append(&#039;notifications&#039;, view(&#039;layouts.notification&#039;, [\n                    &#039;message&#039; =&amp;gt; __(&#039;Chirp deleted.&#039;),\n                ])),\n                turbo_stream()-&amp;gt;flash(__(&#039;Chirp deleted.&#039;)),\n            ]);\n        }\n\n        \/\/ ...\n    }\n}\n\n\nTurbo Streams Combo\n\nYou may combine multiple Turbo Streams in a single response like so:\n\nreturn turbo_stream([\n    turbo_stream()\n        -&amp;gt;append($comment)\n        -&amp;gt;target(dom_id($comment-&amp;gt;post, &#039;comments&#039;)),\n    turbo_stream()\n        -&amp;gt;update(dom_id($comment-&amp;gt;post, &#039;comments_count&#039;), view(&#039;posts.partials.comments_count&#039;, [\n            &#039;post&#039; =&amp;gt; $comment-&amp;gt;post,\n        ])),\n]);\n\n\nAlthough this is a valid option, it might feel like too much work for a controller. If that&#039;s the case, you may use Custom Turbo Stream Views.\n\nCustom Turbo Stream Views\n\nAlthough combining Turbo Streams in a single response right there in the controller is a valid option, it may feel like too much work for a controller. If that&#039;s the case, you may want to extract the Turbo Streams to a Blade view and respond with that instead:\n\nreturn turbo_stream_view(&#039;comments.turbo.created_stream&#039;, [\n    &#039;comment&#039; =&amp;gt; $comment,\n]);\n\n\nSimilar to the turbo_stream() helper function and the Response::turboStream() macro, you may prefer using the Response::turboStreamView() macro. It works the same way.\n\nHere&#039;s an example of a more complex custom Turbo Stream view:\n\n{{&#039;@&#039;}}include(&#039;layouts.turbo.flash_stream&#039;)\n\n&amp;lt;turbo-stream target=&amp;quot;{{&#039;@&#039;}}domid($comment-&amp;gt;post, &#039;comments&#039;)&amp;quot; action=&amp;quot;append&amp;quot;&amp;gt;\n    &amp;lt;template&amp;gt;\n        {{&#039;@&#039;}}include(&#039;comments.partials.comment&#039;, [&#039;comment&#039; =&amp;gt; $comment])\n    &amp;lt;\/template&amp;gt;\n&amp;lt;\/turbo-stream&amp;gt;\n\n\nRemember, these are Blade views, so you have the full power of Blade at your hands. In this example, we&#039;re including a shared Turbo Stream partial which could append any flash messages we may have. That layouts.turbo.flash_stream could look like this:\n\n{{&#039;@&#039;}}if (session()-&amp;gt;has(&#039;status&#039;))\n&amp;lt;turbo-stream target=&amp;quot;notice&amp;quot; action=&amp;quot;append&amp;quot;&amp;gt;\n    &amp;lt;template&amp;gt;\n        {{&#039;@&#039;}}include(&#039;layouts.partials.flash&#039;)\n    &amp;lt;\/template&amp;gt;\n&amp;lt;\/turbo-stream&amp;gt;\n{{&#039;@&#039;}}endif\n\n\nSimilar to the &amp;lt;x-turbo::frame&amp;gt; Blade component, there&#039;s also a &amp;lt;x-turbo::stream&amp;gt; Blade component that can simplify things a bit. It has the same convention of figuring out the DOM ID when you&#039;re passing a model instance or an array as target attribute of the &amp;lt;x-turbo::frame&amp;gt; component. When using the component version, there&#039;s no need to specify the template wrapper for the Turbo Stream tag, as that will be added by the component itself. So, the same example would look something like this:\n\n{{&#039;@&#039;}}include(&#039;layouts.turbo.flash_stream&#039;)\n\n&amp;lt;x-turbo::stream :target=&amp;quot;[$comment-&amp;gt;post, &#039;comments&#039;]&amp;quot; action=&amp;quot;append&amp;quot;&amp;gt;\n    {{&#039;@&#039;}}include(&#039;comments.partials.comment&#039;, [&#039;comment&#039; =&amp;gt; $comment])\n&amp;lt;\/x-turbo::stream&amp;gt;\n\n\nI hope you can see how powerful this can be to reusing views.\n\nCustom Actions\n\nYou may also use the &amp;lt;x-turbo::stream&amp;gt; Blade component for your custom actions as well:\n\n&amp;lt;x-turbo::stream action=&amp;quot;console_log&amp;quot; value=&amp;quot;Hello World&amp;quot; \/&amp;gt;\n\n\nCustom actions are only supported from Blade views. You cannot return those from controllers using the Pending Streams Builder.&quot;",
        "url": "https://turbo-laravel.com/docs/turbo-streams",
      },
          "broadcasting": {
        "title": "Broadcasting",
        "content": "&quot;So far, we&#039;ve seen how we may generate Turbo Streams to either add it to our Blade views or return them from controllers after a form submission over HTTP. In addition to that, we may also broadcast model changes over WebSockets (or Server-Sent Events).\n\nIt&#039;s important to mention that this is an optional feature of Turbo and Turbo Laravel. You don&#039;t have to use Turbo Streams Broadcasting if you don&#039;t have the need for it in order to use Turbo.\n\nWe can make our model changes generate Turbo Streams. Yes, the exact same Turbo Streams tags we&#039;re used to. Remember, \&quot;HTML over the wire.\&quot; Turbo Streams Broadcasting use Laravel Echo and Laravel&#039;s Broadcasting component.\n\nBroadcasts are usually triggered after a form submission. You may still return Turbo Streams over HTTP to the user that triggered the form submission, and only send the Turbo Stream Broadcasting to other users. This way, the user making the change will have an instant feedback compared to having to wait for the broadcasting over WebSockets, which may involve queue workers.\n\nConfiguration\n\nBroadcasting Turbo Streams relies heavily on Laravel&#039;s Broadcasting  component. This means you need to configure Laravel Echo in the frontend and either Laravel Reverb or a paid service like Pusher.\n\nListening to Broadcasts\n\nTurbo Laravel will publish a custom HTML tag to your application&#039;s resources\/js\/elements folder. This tag is called &amp;lt;turbo-echo-stream-source&amp;gt; (see here).\n\nYou may add this tag to any Blade view passing the channel you want to listen to and users will start receiving Turbo Stream Broadcasts right away:\n\n&amp;lt;turbo-echo-stream-source\n    channel=&amp;quot;App.Models.Post.@{{ $post-&amp;gt;id }}&amp;quot;\n\/&amp;gt;\n\n\nFor convenience, you may prefer using the &amp;lt;x-turbo::stream-from&amp;gt; Blade component that ships with Turbo Laravel (it requires that you have a custom element named &amp;lt;turbo-echo-stream-source&amp;gt; available, since that&#039;s the tag this component will render in HTML). You may pass the model as the source prop to it, it will figure out the channel name for that specific model using Laravel&#039;s conventions:\n\n&amp;lt;x-turbo::stream-from :source=&amp;quot;$post&amp;quot; \/&amp;gt;\n\n\nBy default, it expects a private channel, so it must be used in a page where users are already authenticated. You may control the channel type in the tag with a type attribute.\n\n&amp;lt;x-turbo::stream-from :source=&amp;quot;$post&amp;quot; type=&amp;quot;public&amp;quot; \/&amp;gt;\n\n\nMake sure you have the Broadcast Auth Route for your models registered in your routes\/channels.php file:\n\nuse App\\Models\\Post;\nuse App\\Models\\User;\nuse Illuminate\\Support\\Facades\\Broadcast;\n\nBroadcast::channel(Post::class, function (User $user, Post $post) {\n    return $user-&amp;gt;belongsToTeam($post-&amp;gt;team);\n});\n\n\nYou may want to read the Laravel Broadcasting documentation.\n\nBroadcasting Model Changes\n\nTo be broadcast model changes for a particular, you must add the Broadcasts trait to your models:\n\nuse HotwiredLaravel\\TurboLaravel\\Models\\Broadcasts;\n\nclass Comment extends Model\n{\n    use Broadcasts;\n}\n\n\nThis trait will augment any model with Turbo Stream broadcasting methods that you may use to trigger broadcasts manually. Here&#039;s how you can broadcast an append Turbo Stream for a newly created comment to all users visiting the post page:\n\nRoute::post(&#039;posts\/{post}\/comments&#039;, function (Post $post) {\n    $comment = $post-&amp;gt;comments()-&amp;gt;create(\/** params *\/);\n\n    $comment-&amp;gt;broadcastAppend()-&amp;gt;toOthers()-&amp;gt;later();\n\n    if (request()-&amp;gt;wantsTurboStream()) {\n        return turbo_stream($comment);\n    }\n\n    return back();\n});\n\n\nHere are the methods now available to your model:\n\n$comment-&amp;gt;broadcastAppend();\n$comment-&amp;gt;broadcastPrepend();\n$comment-&amp;gt;broadcastBefore(&#039;target_dom_id&#039;);\n$comment-&amp;gt;broadcastAfter(&#039;target_dom_id&#039;);\n$comment-&amp;gt;broadcastReplace();\n$comment-&amp;gt;broadcastUpdate();\n$comment-&amp;gt;broadcastRemove();\n$comment-&amp;gt;broadcastRefresh();\n\n\nThese methods will assume you want to broadcast to your model&#039;s channel. In this case, it would broadcast the Turbo Streams to a private channel named App.Models.Comments.{id}.\n\nAdditionally, you may send these broadcasts to any other model&#039;s channel:\n\n$comment-&amp;gt;broadcastAppendTo($post);\n$comment-&amp;gt;broadcastPrependTo($post);\n$comment-&amp;gt;broadcastBeforeTo($post, &#039;target_dom_id&#039;);\n$comment-&amp;gt;broadcastAfterTo($post, &#039;target_dom_id&#039;);\n$comment-&amp;gt;broadcastReplaceTo($post);\n$comment-&amp;gt;broadcastUpdateTo($post);\n$comment-&amp;gt;broadcastRemoveTo($post);\n$comment-&amp;gt;broadcastRefreshTo($post);\n\n\nThese broadcastXTo() methods accept either a model, an instance of the Channel class, or an array containing both of these.\n\nWhen it receives a model, it will guess the channel name using Laravel&#039;s Broadcasting channel naming convention.\n\nAll of these broadcasting methods return an instance of the PendingBroadcast class that will only dispatch the broadcasting job when that pending object is being garbage collected. Which means you may make changes to this pending broadcast by chaining on the returned object:\n\n$comment-&amp;gt;broadcastAppend()\n    -&amp;gt;to($post)\n    -&amp;gt;view(&#039;comments\/_custom_view_partial&#039;, [\n        &#039;comment&#039; =&amp;gt; $comment,\n        &#039;post&#039; =&amp;gt; $post,\n    ])\n    -&amp;gt;toOthers() \/\/ Do not send to the current user...\n    -&amp;gt;later(); \/\/ Don&#039;t send it now, dispatch a job to send in background instead...\n\n\nYou may want to hook these broadcasts from your model&#039;s events to trigger Turbo Stream broadcasts whenever your models are changed in any context:\n\nclass Comment extends Model\n{\n    use Broadcasts;\n\n    protected static function booted()\n    {\n        static::created(function (Comment $comment) {\n            $comment-&amp;gt;broadcastPrependTo($comment-&amp;gt;post)-&amp;gt;later();\n        });\n\n        static::updated(function (Comment $comment) {\n            $comment-&amp;gt;broadcastReplaceTo($comment-&amp;gt;post)-&amp;gt;later();\n        });\n\n        static::deleted(function (Comment $comment) {\n            $comment-&amp;gt;broadcastRemoveTo($comment-&amp;gt;post)-&amp;gt;later();\n        });\n    }\n}\n\n\nFor convenience, instead of adding all these lines to achieve this set of broadcasting, you may add a $broadcasts = true property to your model class. This property instructs the Brodcasts trait to automatically hook the model Turbo Stream broadcasts on the correct events:\n\nclass Comment extends Model\n{\n    use Broadcasts;\n\n    protected $broadcasts = true;\n}\n\n\nThis achieves almost the same set of Broadcasts as the previous example, with a few nuanced differences. First, by default, it will broadcast an append Turbo Stream on newly created models. You may want to use prepend instead. You may do that by changing the $broadcasts property to be a configuration array instead of a boolean true, then set the insertsBy key to prepend:\n\nclass Comment extends Model\n{\n    use Broadcasts;\n\n    protected $broadcasts = [\n        &#039;insertsBy&#039; =&amp;gt; &#039;prepend&#039;,\n    ];\n}\n\n\nWhen using the $broadcasts property, the Turbo Stream broadcasts will be sent to the current model&#039;s channel. However, since the channels use the model&#039;s ID as per the naming convention, no one will ever be able to listen on that channel before the model is created. For that reason, Turbo Stream broadcasts of newly created models will be sent to a private channel using the model&#039;s plural name instead. You may also configure which stream name this specific Turbo Stream should be sent to by setting the stream key on the $broadcasts property:\n\nclass Comment extends Model\n{\n    use Broadcasts;\n\n    protected $broadcasts = [\n        &#039;insertsBy&#039; =&amp;gt; &#039;prepend&#039;,\n        &#039;stream&#039; =&amp;gt; &#039;my-comments&#039;,\n    ];\n}\n\n\nThis will send the Turbo Stream broadcast to private channel called my-comments when a new comment is created.\n\nAlternatively, you may also set a $broadcastsTo property with either a string with the name of the relationship to be used to resolve the channel, or an array of relationships if you want to send the broadcast to multiple related model&#039;s channels:\n\nclass Comment extends Model\n{\n    use Broadcasts;\n\n    protected $broadcasts = [\n        &#039;insertsBy&#039; =&amp;gt; &#039;prepend&#039;,\n    ];\n\n    protected $broadcastsTo = &#039;post&#039;;\n\n    public function post()\n    {\n        return $this-&amp;gt;belongsTo(Post::class);\n    }\n}\n\n\nYou may also do that by adding a broadcastsTo() method to your model instead of the $broadcastsTo property. The method must return either an Eloquent model, a Channel instance, or an array with a mix of those:\n\nuse Illuminate\\Broadcasting\\Channel;\n\nclass Comment extends Model\n{\n    use Broadcasts;\n\n    protected $broadcasts = [\n        &#039;insertsBy&#039; =&amp;gt; &#039;prepend&#039;,\n    ];\n\n    public function post()\n    {\n        return $this-&amp;gt;belongsTo(Post::class);\n    }\n\n    public function broadcastsTo()\n    {\n        return [\n            $this,\n            $this-&amp;gt;post,\n            new Channel(&#039;full-control&#039;),\n        ];\n    }\n}\n\n\nHaving a $broadcastsTo property or implementing the broadcastsTo() method in your model will have precedence over the stream key of the $broadcasts property.\n\nBroadcasting Page Refreshes\n\nSimilar to the $broadcasts property, you may want to automatically configure page refresh broadcasts on a modal. You may use the $broadcastsRefreshes property for that:\n\nuse Illuminate\\Broadcasting\\Channel;\n\nclass Comment extends Model\n{\n    use Broadcasts;\n\n    protected $broadcastsRefreshes = true;\n}\n\n\nThis is the same as doing:\n\nuse Illuminate\\Broadcasting\\Channel;\n\nclass Comment extends Model\n{\n    use Broadcasts;\n\n    public static function booted()\n    {\n        static::created(function ($comment) {\n            $comment-&amp;gt;broadcastRefreshTo(&amp;quot;comments&amp;quot;)-&amp;gt;later();\n        });\n\n        static::updated(function ($comment) {\n            $comment-&amp;gt;broadcastRefresh()-&amp;gt;later();\n        });\n\n        static::deleted(function ($comment) {\n            $comment-&amp;gt;broadcastRefresh();\n        });\n    }\n}\n\n\nYou may want to broadcast page refreshes to a related model:\n\nuse Illuminate\\Broadcasting\\Channel;\n\nclass Comment extends Model\n{\n    use Broadcasts;\n\n    protected $broadcastsRefreshes = true;\n\n    protected $broadcastsRefreshesTo = [&#039;post&#039;];\n\n    public function post()\n    {\n        return $this-&amp;gt;belongsTo(Post::class);\n    }\n}\n\n\nThis will send page refreshes broadcasts to the related Post model channel.\n\nAlternatively, you may specific a broadcastsRefreshesTo method instead of a property:\n\nuse Illuminate\\Broadcasting\\Channel;\n\nclass Comment extends Model\n{\n    use Broadcasts;\n\n    protected $broadcastsRefreshes = true;\n\n    public function post()\n    {\n        return $this-&amp;gt;belongsTo(Post::class);\n    }\n\n    public function broadcastsRefreshesTo()\n    {\n        return [$this-&amp;gt;post];\n    }\n}\n\n\nFrom this method, you may return an instance of an Eloquent model, a string representing the channel name, or an instance of a Channel class.\n\nBroadcasting Turbo Streams to Other Users Only\n\nAs mentioned earlier, you may want to feed the current user with Turbo Streams using HTTP requests and only send the broadcasts to other users. You may achieve that by chaining on the pending broadcast object that returns from all broadcastX methods:\n\n$comment-&amp;gt;broadcastAppendTo($post)-&amp;gt;toOthers();\n\n\nAlternatively, you may use the Turbo Facade like so to configure a scope where all broadcast Turbo Streams triggered inside of it will be sent to other users only:\n\nuse HotwiredLaravel\\TurboLaravel\\Facades\\Turbo;\n\nTurbo::broadcastToOthers(function () {\n    \/\/ ...\n});\n\n\nIf you always want to send broadcasts to other users excluding the current user from receiving broadcasts, you may call the broadcastToOthers without passing a closure to it somewhere globally like a middleware or the AppServiceProvider::boot() method:\n\n&amp;lt;?php\n\nnamespace App\\Providers;\n\nuse Illuminate\\Support\\ServiceProvider;\nuse HotwiredLaravel\\TurboLaravel\\Facades\\Turbo;\n\nclass AppServiceProvider extends ServiceProvider\n{\n    public function boot()\n    {\n        Turbo::broadcastToOthers();\n    }\n}\n\n\nThis only applies to broadcasts generated in an HTTP request, because this relies on having the X-Socket-ID header in the request, which Laravel Echo sets automatically. Any broadcast generate from a queue worker, for instance, will always be broadcast to all users listening on the broadcast channels.\n\nHandmade Broadcasts\n\nYou may want to broadcast something independently of a model. You may do so using the HotwiredLaravel\\TurboLaravel\\Facades\\TurboStream Facade (if you&#039;re not into Facades, type-hinting the HotwiredLaravel\\TurboLaravel\\Broadcasting\\Factory class should also work):\n\nTurboStream::broadcastAppend(\n    content: __(&#039;Hello World&#039;),\n    target: &#039;notifications&#039;,\n    channel: &#039;general&#039;,\n);\n\n\nModel broadcasts use this same abstraction under the hood, so you have similar methods available:\n\nTurboStream::broadcastAppend();\nTurboStream::broadcastPrepend();\nTurboStream::broadcastBefore();\nTurboStream::broadcastAfter();\nTurboStream::broadcastUpdate();\nTurboStream::broadcastReplace();\nTurboStream::broadcastRemove();\nTurboStream::broadcastRefresh();\n\n\nAll of these methods, except the broadcastRemove() and broadcastRefresh, accept a $content parameter that may be a View instance, an instance of the HtmlString class, or a simple string:\n\n\/\/ Passing a view instance as content...\nTurboStream::broadcastAppend(\n    content: view(&#039;layouts.notification&#039;, [&#039;message&#039; =&amp;gt; &#039;Hello World&#039;]),\n    target: &#039;notifications&#039;,\n    channel: &#039;general&#039;,\n);\n\n\/\/ Passing an instance of the HtmlString class (won&#039;t be escaped by Blade)...\nTurboStream::broadcastAppend(\n    content: new HtmlString(&#039;Hello World&#039;),\n    target: &#039;notifications&#039;,\n    channel: &#039;general&#039;,\n);\n\n\/\/ Passing a simple string (will be escaped by Blade)...\nTurboStream::broadcastAppend(\n    content: &#039;Hello World&#039;,\n    target: &#039;notifications&#039;,\n    channel: &#039;general&#039;,\n);\n\n\nYou may also customize the Turbo Stream by chaining on the returned PendingBroadcast object:\n\nTurboStream::broadcastAppend(&#039;Hello World&#039;)\n    -&amp;gt;target(&#039;notifications&#039;)\n    -&amp;gt;to(&#039;general&#039;);\n\n\nAs for the channel, you may pass a string that will be interpreted as a public channel name, an Eloquent model which will resolve to a private channel using that model&#039;s broadcasting channel convention, or instances of the Illuminate\\Broadcasting\\Channel class.\n\nYou may want to specify private or presence string channels instead of public ones:\n\nTurboStream::broadcastAppend(&#039;Hello World&#039;)\n    -&amp;gt;target(&#039;notifications&#039;)\n    -&amp;gt;toPrivateChannel(&#039;user.123&#039;);\n\nTurboStream::broadcastAppend(&#039;Hello World&#039;)\n    -&amp;gt;target(&#039;notifications&#039;)\n    -&amp;gt;toPresenceChannel(&#039;user.123&#039;);\n\n\nUsing the broadcastAction() will allow you to broadcast any custom Turbo Stream action, so you&#039;re not limited to the default ones when using this approach:\n\nTurboStream::broadcastAction(&#039;scroll_to&#039;, target: &#039;todo_123&#039;);\n\n\nHandmade Broadcasting Using The turbo_stream() Response Builder\n\nOne more alternative to broadcasting Turbo Streams is to call the broadcastTo() method on the returned object of the turbo_stream() function:\n\nturbo_stream()\n    -&amp;gt;append(&#039;notifications&#039;, &#039;Hello World&#039;)\n    -&amp;gt;broadcastTo(&#039;general&#039;);\n\n\nThis will tap on the PendingTurboStreamResponse and create a PendingBroadcast from it. It&#039;s important to note that this will return the same PendingTurboStreamResponse, not the PendingBroadcast. If you want to configure the PendingBroadcast that will be generated, you must do that before calling the broadcastTo() method, but you may also pass a Closure as the second parameter:\n\nturbo_stream()\n    -&amp;gt;append(&#039;notifications&#039;, &#039;Hello World&#039;)\n    -&amp;gt;broadcastTo(&#039;general&#039;, fn ($broadcast) =&amp;gt; $broadcast-&amp;gt;toOthers());\n\n\nThe first argument must be either a string, an Eloquent model, or an instance of the Illuminate\\Broadcasting\\Channel class as the channel:\n\nturbo_stream($comment)\n    -&amp;gt;broadcastTo($comment-&amp;gt;post, fn ($broadcast) =&amp;gt; $broadcast-&amp;gt;toOthers());\n\n\nSimilarly to using the Facade, you may also want to broadcast to private or presence string channels like so:\n\n\/\/ Broadcast to private channels...\nturbo_stream()\n    -&amp;gt;append(&#039;notifications&#039;, &#039;Hello World&#039;)\n    -&amp;gt;broadcastToPrivateChannel(&#039;user.123&#039;, fn ($broadcast) =&amp;gt; $broadcast-&amp;gt;toOthers())\n\n\/\/ Broadcast to presence channels...\nturbo_stream()\n    -&amp;gt;append(&#039;notifications&#039;, &#039;Hello World&#039;)\n    -&amp;gt;broadcastToPresenceChannel(&#039;chat.123&#039;, fn ($broadcast) =&amp;gt; $broadcast-&amp;gt;toOthers());&quot;",
        "url": "https://turbo-laravel.com/docs/broadcasting",
      },
          "validation-response": {
        "title": "Validation Response",
        "content": "&quot;By default, Laravel redirects failed validation exceptions \&quot;back\&quot; to the page where the request came from. This isn&#039;t usually a problem, in fact it&#039;s the expected behavior, since that page usually is the one where the form which triggered the request renders.\n\nHowever, this is a bit of a problem when it comes to Turbo Frames, since a form might get injected into a page that doesn&#039;t initially render it. The problem is that after a failed validation exception from that form, Laravel would redirect it \&quot;back\&quot; to the page where the form got injected and since the form is not rendered there initially, the user would see the form disappear.\n\nIn other words, we can&#039;t redirect \&quot;back\&quot; to display the form again with the error messages, because the form might not be re-rendered there originally. Instead, Turbo expects that we return a non-200 HTTP status code with the form and validation messages right way after a failed validation exception is thrown.\n\nTurbo Laravel automatically prepends a TurboMiddleware on the web route group. The middleware will intercept the response when it detects that Laravel is responding after a ValidationException. Instead of letting it send the \&quot;redirect back\&quot; response, it will try to guess where the form for that request usually renders and send an internal request back to the app to render the form, then update the status code so it renders as a 422 instead of 200.\n\nTo guess where the form is located at we rely on the route resource naming convention. For any route name ending in .store, it will guess that the form can be located in a similar route ending with .create for the same resource. Similarly, for any route ending with .update, it will guess the form is located at a route ending with .edit. Additionally, for any route ending with .destroy, it will guess the form is located at a route ending with .delete (this is the only convention that is not there by default in Laravel&#039;s conventions.)\n\nFor this internal request, the middleware will pass along any resource the current route has as well as any query string that was passed.\n\nHere are some examples:\n\n\nposts.comments.store will guess the form is at the posts.comments.create route with the {post} route param.\ncomments.store will guess the form is at the comments.create route with no route params.\ncomments.update will guess the form is at the comments.edit with the {comment} param.\n\n\nIf a guessed route name doesn&#039;t exist (which will always happen if you don&#039;t use the route resource convention), the middleware will not change the default handling of validation errors, so the regular \&quot;redirect back\&quot; behavior will act.\n\nWhen you&#039;re not using the resource route naming convention, you may override redirect behavior by catching the ValidationException and re-throwing it setting the correct location where the form renders using the redirectTo method. If the exception has that, the middleware will respect it and make a GET request to that location instead of trying to guess it:\n\npublic function store()\n{\n  try {\n     request()-&amp;gt;validate([&#039;name&#039; =&amp;gt; &#039;required&#039;]);\n  } catch (\\Illuminate\\Validation\\ValidationException $exception) {\n    throw $exception-&amp;gt;redirectTo(url(&#039;\/somewhere&#039;));\n  }\n}\n\n\nIf you want to register exceptions to this route guessing behavior, add the URIs to the redirect_guessing_exceptions key in the config\/turbo-laravel.php config file:\n\nreturn [\n    \/\/ ...\n    &#039;redirect_guessing_exceptions&#039; =&amp;gt; [\n        &#039;\/some-page&#039;,\n    ],\n];\n\n\nThe Turbo HTTP Middleware\n\nTurbo Laravel ships with a middleware which applies some conventions on your redirects, like the one for how failed validations are handled automatically by Laravel as described before. Read more about this in the Conventions section of the documentation.\n\nThe middleware is automatically prepended to your web route group middleware stack. You may want to add the middleware to other groups. When doing so, make sure it&#039;s at the top of the middleware stack:\n\n\\HotwiredLaravel\\TurboLaravel\\Http\\Middleware\\TurboMiddleware::class,\n\n\nLike so:\n\nnamespace App\\Http;\n\nuse Illuminate\\Foundation\\Http\\Kernel as HttpKernel;\n\nclass Kernel extends HttpKernel\n{\n    protected $middlewareGroups = [\n        &#039;web&#039; =&amp;gt; [\n            \\HotwiredLaravel\\TurboLaravel\\Http\\Middleware\\TurboMiddleware::class,\n            \/\/ other middlewares...\n        ],\n    ];\n}&quot;",
        "url": "https://turbo-laravel.com/docs/validation-response-redirects",
      },
          "csrf-protection": {
        "title": "CSRF Protection",
        "content": "&quot;Laravel has built-in CSRF protection in place. It prevents our app from processing any non-GET requests that doesn&#039;t include a valid CSRF Token that was generated in our backend.\n\nSo, to allow a POST form to be processed, we usually need to add a @csrf Blade directive to our forms:\n\n&amp;lt;form action=&amp;quot;@{{ route(&#039;chirps.store&#039;) }}&amp;quot; method=&amp;quot;post&amp;quot;&amp;gt;\n    {{&#039;@&#039;}}csrf\n    &amp;lt;!-- ... --&amp;gt;\n&amp;lt;\/form&amp;gt;\n\n\nSince Turbo.js intercepts form submissions and converts those to fetch requests (AJAX), we don&#039;t actually need the @csrf token applied to each form. Turbo is smart enough to read our page&#039;s meta tags, look for one named csrf-token and use its contents to add the token to all form submissions it intercepts. Jetstream and Breeze both ship with such element in the layout files, but in case you&#039;re missing it in your views, it should look like this:\n\n&amp;lt;meta name=&amp;quot;csrf-token&amp;quot; content=&amp;quot;@{{ csrf_token() }}&amp;quot;&amp;gt;\n\n\nWith that being said, you may still want to use the @csrf Blade directive if you want to support users with JavaScript disabled, since the forms will still work if they contain the CSRF token.&quot;",
        "url": "https://turbo-laravel.com/docs/csrf",
      },
          "hotwire-native": {
        "title": "Hotwire Native",
        "content": "&quot;Hotwire also has a mobile side and Turbo Laravel provides some helpers to help integrating with that.\n\nTurbo visits made by a Hotwire Native client should send a custom User-Agent header. Using that header, we can detect in the backend that a request is coming from a Hotwire Native client instead of a regular web browser.\n\nThis is useful if you want to customize the behavior a little bit different based on that information. For instance, you may want to include some elements for mobile users, like a mobile-only CSS stylesheet, for instance. To do so, you may use the @hotwirenative Blade directive in your Blade views:\n\n{{&#039;@&#039;}}hotwirenative\n    &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;mobile.css&amp;quot;&amp;gt;\n{{&#039;@&#039;}}endhotwirenative\n\n\nAlternatively, you may want to include some elements only if the client requesting it is NOT a Hotwire Native client using the @unlesshotwirenative Blade helpers:\n\n{{&#039;@&#039;}}unlesshotwirenative\n    &amp;lt;h1&amp;gt;Hello, Non-Hotwire Native Users!&amp;lt;\/h1&amp;gt;\n{{&#039;@&#039;}}endunlesshotwirenative\n\n\nYou may also check if the request was made from a Hotwire Native visit using the request macro:\n\nif (request()-&amp;gt;wasFromHotwireNative()) {\n    \/\/ ...\n}\n\n\nOr the Turbo Facade directly, like so:\n\nuse HotwiredLaravel\\TurboLaravel\\Facades\\Turbo;\n\nif (Turbo::isHotwireNativeVisit()) {\n    \/\/ ...\n}\n\n\nInteracting With Hotwire Native Navigation\n\nHotwire Native will hook into Turbo&#039;s visits so it displays them on mobile mimicking the mobile way of stacking screens instead of just replace elements on the same screen. This helps the native feel of our hybrid app.\n\nHowever, sometimes we may need to customize the behavior of form request handler to avoid a weird screen jumping effect happening on the mobile client. Instead of regular redirects, we can send some signals by redirecting to specific routes that are detected by the Hotwire Native client.\n\nFor instance, if a form submission request came from a Hotwire Native client, the form was probably rendered on a native modal, which is not part of the screen stack, so we can just tell Turbo to refresh the current screen it has on stack instead. There are 3 signals we can send to the Hotwire Native client:\n\n\n\n\n  Signal\n  Route\n  Description\n\n\n\n\n  recede\n  \/recede_historical_location\n  Go back to previous screen\n\n\n  resume\n  \/resume_historical_location\n  Stay on the current screen as is\n\n\n  refresh\n  \/refresh_historical_location\n  Stay on the current screen but refresh\n\n\n\n\nSending these signals is a matter of detecting if the request came from a Hotwire Native client and, if so, redirect the user to these signal URLs instead. The Hotwire Native client should detect the redirect was from one of these special routes and trigger the desired behavior.\n\nYou may use the InteractsWithHotwireNativeNavigation trait on your controllers to achieve this behavior and fallback to a regular redirect if the request wasn&#039;t from a Hotwire Native client:\n\nuse HotwiredLaravel\\TurboLaravel\\Http\\Controllers\\Concerns\\InteractsWithHotwireNativeNavigation;\n\nclass TraysController extends Controller\n{\n    use InteractsWithHotwireNativeNavigation;\n\n    public function store()\n    {\n        \/\/ Tray creation...\n\n        return $this-&amp;gt;recedeOrRedirectTo(route(&#039;trays.show&#039;, $tray));\n    }\n}\n\n\nIn this example, when the request to create trays comes from a Hotwire Native client, we&#039;re going to redirect to the \/recede_historical_location URL instead of the trays.show route. However, if the request was made from your web app, we&#039;re going to redirect the client to the trays.show route.\n\nThere are a couple of redirect helpers available:\n\n$this-&amp;gt;recedeOrRedirectTo(string $url);\n$this-&amp;gt;resumeOrRedirectTo(string $url);\n$this-&amp;gt;refreshOrRedirectTo(string $url);\n$this-&amp;gt;recedeOrRedirectBack(string $fallbackUrl, array $options = []);\n$this-&amp;gt;resumeOrRedirectBack(string $fallbackUrl, array $options = []);\n$this-&amp;gt;refreshOrRedirectBack(string $fallbackUrl, array $options = []);\n\n\nIt&#039;s common to flash messages using the -&amp;gt;with() method of the Redirect response in Laravel. However, since a Hotwire Native request will never actually redirect somewhere where the flash message will be rendered, the behavior of the -&amp;gt;with() method was slightly modified too.\n\nIf you&#039;re setting flash messages like this after a form submission:\n\nuse HotwiredLaravel\\TurboLaravel\\Http\\Controllers\\Concerns\\InteractsWithHotwireNativeNavigation;\n\nclass TraysController extends Controller\n{\n    use InteractsWithHotwireNativeNavigation;\n\n    public function store()\n    {\n        \/\/ Tray creation...\n\n        return $this-&amp;gt;recedeOrRedirectTo(route(&#039;trays.show&#039;, $tray))\n            -&amp;gt;with(&#039;status&#039;, __(&#039;Tray created.&#039;));\n    }\n}\n\n\nIf a request was sent from a Hotwire Native client, the flashed messages will be added to the query string instead of flashed into the session like they&#039;d normally be. In this example, it would redirect like this:\n\n\/recede_historical_location?status=Tray%20created.\n\n\nIn the Hotwire Native client, you should be able to intercept these redirects, retrieve the flash messages from the query string and create native toasts, if you&#039;d like to.\n\nIf the request wasn&#039;t from a Hotwire Native client, the message would be flashed into the session as normal, and the client would receive a redirect to the trays.show route in this case.\n\nIf you don&#039;t want these routes enabled, feel free to disable them by commenting out the feature on your config\/turbo-laravel.php file (make sure the Turbo Laravel configs are published):\n\nreturn [\n    &#039;features&#039; =&amp;gt; [\n        \/\/ Features::hotwireNativeRoutes(),\n    ],\n];&quot;",
        "url": "https://turbo-laravel.com/docs/hotwire-native",
      },
          "testing": {
        "title": "Testing",
        "content": "&quot;Testing a Hotwired app is like testing a regular Laravel app. However, Turbo Laravel comes with a set of helpers that may be used to ease testing some aspects that are specific to Turbo:\n\n\nTurbo HTTP Request Helpers. When you may want to mimic a Turbo visit, or a Hotwire Native visit, or a request coming from a Turbo Frame.\nTurbo Streams on HTTP Responses. When you may want to test the Turbo Streams returned from HTTP requests.\nTurbo Stream Broadcasts. When you&#039;re either using the broadcast methods on your models using the Broadcasts trait, or when you&#039;re using Handmade Turbo Stream Broadcasts.\n\n\nLet&#039;s dig into those aspects and how you may test them.\n\nTurbo HTTP Request Helpers\n\nTo enhance your testing capabilities when using Turbo, Turbo Laravel adds a few macros to the TestResponse that Laravel uses under the hood. It also ships with a InteractsWithTurbo trait that adds Turbo-specific testing helper methods. The goal is to allow mimicking a request and inspecting the response in a very Laravel way.\n\nActing as Turbo Visits\n\nTurbo visits are marked with a Accept: text\/vnd.turbo-stream.html, ... header, which you may want to respond differently (maybe returning a Turbo Streams document instead of plain HTML). To be able to make request adding that header, you may add the InteractsWithTurbo trait to your current test class (or to the base TestCase). Then, you may use the $this-&amp;gt;turbo() method before issuing a request:\n\nuse HotwiredLaravel\\TurboLaravel\\Testing\\InteractsWithTurbo;\n\nclass CreateCommentsTest extends TestCase\n{\n    use InteractsWithTurbo;\n\n    \/** {{&#039;@&#039;}}test *\/\n    public function creates_comments()\n    {\n        $post = Post::factory()-&amp;gt;create();\n\n        $this-&amp;gt;assertCount(0, $post-&amp;gt;comments);\n\n        $this-&amp;gt;turbo()-&amp;gt;post(route(&#039;posts.comments.store&#039;, $post), [\n            &#039;content&#039; =&amp;gt; &#039;Hello World&#039;,\n        ])-&amp;gt;assertOk();\n\n        $this-&amp;gt;assertCount(1, $post-&amp;gt;refresh()-&amp;gt;comments);\n        $this-&amp;gt;assertEquals(&#039;Hello World&#039;, $post-&amp;gt;comments-&amp;gt;first()-&amp;gt;content);\n    }\n}\n\n\nWhen using this method, calls to request()-&amp;gt;wantsTurboStream() will return true.\n\nActing as Turbo Frame Requests\n\nYou may want to handle requests a bit differently based on whether they came from a request triggered inside a Turbo Frame or not. To mimic a request coming from a Turbo Frame, you may use the fromTurboFrame() helper from the InteractsWithTurbo trait:\n\nuse HotwiredLaravel\\TurboLaravel\\Testing\\InteractsWithTurbo;\n\nclass CreateCommentsTest extends TestCase\n{\n    use InteractsWithTurbo;\n\n    \/** {{&#039;@&#039;}}test *\/\n    public function create_comment()\n    {\n        $article = Article::factory()-&amp;gt;create();\n\n        $this-&amp;gt;fromTurboFrame(dom_id($article, &#039;create_comment&#039;))\n            -&amp;gt;post(route(&#039;articles.comments.store&#039;, $article), [...])\n            -&amp;gt;assertRedirect();\n    }\n}\n\n\nActing as Hotwire Native\n\nAdditionally, when you&#039;re building a Hotwire Native mobile app, you may want to issue a request pretending to be sent from a Hotwire Native client. That&#039;s done by setting the User-Agent header to something that mentions the word Hotwire Native. The InteractsWithTurbo trait also has a $this-&amp;gt;hotwireNative() method you may use that automatically sets the header correctly:\n\nuse HotwiredLaravel\\TurboLaravel\\Testing\\InteractsWithTurbo;\n\nclass CreateCommentsTest extends TestCase\n{\n    use InteractsWithTurbo;\n\n    \/** {{&#039;@&#039;}}test *\/\n    public function creating_comments_from_native_recedes()\n    {\n        $post = Post::factory()-&amp;gt;create();\n\n        $this-&amp;gt;assertCount(0, $post-&amp;gt;comments);\n\n        $this-&amp;gt;hotwireNative()-&amp;gt;post(route(&#039;posts.comments.store&#039;, $post), [\n            &#039;content&#039; =&amp;gt; &#039;Hello World&#039;,\n        ])-&amp;gt;assertOk();\n\n        $this-&amp;gt;assertCount(1, $post-&amp;gt;refresh()-&amp;gt;comments);\n        $this-&amp;gt;assertEquals(&#039;Hello World&#039;, $post-&amp;gt;comments-&amp;gt;first()-&amp;gt;content);\n    }\n}\n\n\nWhen using this method, calls to request()-&amp;gt;wasFromHotwireNative() will return true. Additionally, the @hotwirenative and @unlesshotwirenative Blade directives will render as expected.\n\nA few other macros were added to the TestResponse class to make it easier to assert based on the recede, resume, and refresh redirects using the specific assert methods:\n\n\n\n\n  Method\n  Descrition\n\n\n\n\n  assertRedirectRecede(array $with = [])\n  Asserts that a redirect was returned to the \/recede_historical_location route.\n\n\n  assertRedirectResume(array $with = [])\n  Asserts that a redirect was returned to the \/resume_historical_location route.\n\n\n  assertRedirectRefresh(array $with = [])\n  Asserts that a redirect was returned to the \/refresh_historical_location route.\n\n\n\n\nThe $with argument will ensure that not only the route is correct, but also any flashed message will be included in the query string:\n\nuse HotwiredLaravel\\TurboLaravel\\Testing\\InteractsWithTurbo;\n\nclass CreateCommentsTest extends TestCase\n{\n    use InteractsWithTurbo;\n\n    \/** {{&#039;@&#039;}}test *\/\n    public function creating_comments_from_native_recedes()\n    {\n        $post = Post::factory()-&amp;gt;create();\n\n        $this-&amp;gt;assertCount(0, $post-&amp;gt;comments);\n\n        $this-&amp;gt;hotwireNative()-&amp;gt;post(route(&#039;posts.comments.store&#039;, $post), [\n            &#039;content&#039; =&amp;gt; &#039;Hello World&#039;,\n        ])-&amp;gt;assertRedirectRecede([&#039;status&#039; =&amp;gt; __(&#039;Comment created.&#039;)]);\n\n        $this-&amp;gt;assertCount(1, $post-&amp;gt;refresh()-&amp;gt;comments);\n        $this-&amp;gt;assertEquals(&#039;Hello World&#039;, $post-&amp;gt;comments-&amp;gt;first()-&amp;gt;content);\n    }\n}\n\n\nAsserting Turbo Stream HTTP Responses\n\nYou may test if you got a Turbo Stream response by using the assertTurboStream() response helper macro. Similarly, you may assert that your response was not a Turbo Stream response by using the assertNotTurboStream() response helper macro:\n\nuse HotwiredLaravel\\TurboLaravel\\Testing\\InteractsWithTurbo;\n\nclass CreateTodosTest extends TestCase\n{\n    use InteractsWithTurbo;\n\n    \/** {{&#039;@&#039;}}test *\/\n    public function creating_todo_from_turbo_request_returns_turbo_stream_response()\n    {\n        $this-&amp;gt;turbo()-&amp;gt;post(route(&#039;todos.store&#039;), [\n            &#039;content&#039; =&amp;gt; &#039;Test the app&#039;,\n        ])-&amp;gt;assertTurboStream();\n    }\n\n    \/** {{&#039;@&#039;}}test *\/\n    public function creating_todo_from_regular_request_does_not_return_turbo_stream_response()\n    {\n        \/\/ Notice we&#039;re not chaining the `$this-&amp;gt;turbo()` method here.\n        $this-&amp;gt;post(route(&#039;todos.store&#039;), [\n            &#039;content&#039; =&amp;gt; &#039;Test the app&#039;,\n        ])-&amp;gt;assertNotTurboStream();\n    }\n}\n\n\nThe controller for such response would be something like this:\n\nclass TodosController\n{\n    public function store()\n    {\n        $todo = auth()-&amp;gt;user()-&amp;gt;todos()-&amp;gt;create(request()-&amp;gt;validate([\n            &#039;content&#039; =&amp;gt; [&#039;required&#039;],\n        ]));\n\n        if (request()-&amp;gt;wantsTurboStream()) {\n            return turbo_stream($todo);\n        }\n\n        return redirect()-&amp;gt;route(&#039;todos.index&#039;);\n    }\n}\n\n\nFluent Turbo Stream Assertions\n\nThe assertTurboStream() macro accepts a callback which allows you to assert specific details about your returned Turbo Streams. The callback takes an instance of the AssertableTurboStream class, which has some matching methods to help you building your specific assertion. In the following example, we&#039;re asserting that 2 Turbo Streams were returned, as well as their targets, actions, and even HTML content:\n\n\/** {{&#039;@&#039;}}test *\/\npublic function create_todos()\n{\n    $this-&amp;gt;get(route(&#039;todos.store&#039;))\n        -&amp;gt;assertTurboStream(fn (AssertableTurboStream $turboStreams) =&amp;gt; (\n            $turboStreams-&amp;gt;has(2)\n            &amp;amp;&amp;amp; $turboStreams-&amp;gt;hasTurboStream(fn ($turboStream) =&amp;gt; (\n                $turboStream-&amp;gt;where(&#039;target&#039;, &#039;flash_messages&#039;)\n                            -&amp;gt;where(&#039;action&#039;, &#039;prepend&#039;)\n                            -&amp;gt;see(&#039;Todo was successfully created!&#039;)\n            ))\n            &amp;amp;&amp;amp; $turboStreams-&amp;gt;hasTurboStream(fn ($turboStream) =&amp;gt; (\n                $turboStream-&amp;gt;where(&#039;target&#039;, &#039;todos&#039;)\n                            -&amp;gt;where(&#039;action&#039;, &#039;append&#039;)\n                            -&amp;gt;see(&#039;Test the app&#039;)\n            ))\n        ));\n}\n\n\nTesting Turbo Stream Broadcasts\n\nYou may assert that Turbo Stream broadcasts were sent from any mechanism provided by Turbo Laravel by using the TurboStream::fake() abstraction. This allows you to capture any kind of Turbo Stream broadcasting that happens inside your application and assert on them:\n\nuse App\\Models\\Todo;\nuse HotwiredLaravel\\TurboLaravel\\Facades\\TurboStream;\nuse HotwiredLaravel\\TurboLaravel\\Broadcasting\\PendingBroadcast;\n\nclass CreatesCommentsTest extends TestCase\n{\n    \/** {{&#039;@&#039;}}test *\/\n    public function content_is_required()\n    {\n        TurboStream::fake();\n\n        $todo = Todo::factory()-&amp;gt;create();\n\n        $this-&amp;gt;turbo()-&amp;gt;post(route(&#039;todos.comments.store&#039;, $todo), [\n            &#039;content&#039; =&amp;gt; null,\n        ])-&amp;gt;assertInvalid([&#039;content&#039;]);\n\n        TurboStream::assertNothingWasBroadcasted();\n    }\n\n    \/** {{&#039;@&#039;}}test *\/\n    public function creates_comments()\n    {\n        TurboStream::fake();\n\n        $todo = Todo::factory()-&amp;gt;create();\n\n        $this-&amp;gt;turbo()-&amp;gt;post(route(&#039;todos.comments.store&#039;, $todo), [\n            &#039;content&#039; =&amp;gt; &#039;Hey, this is really nice!&#039;,\n        ])-&amp;gt;assertTurboStream();\n\n        TurboStream::assertBroadcasted(function (PendingBroadcast $broadcast) use ($todo) {\n            return $broadcast-&amp;gt;target === &#039;comments&#039;\n                &amp;amp;&amp;amp; $broadcast-&amp;gt;action === &#039;append&#039;\n                &amp;amp;&amp;amp; $broadcast-&amp;gt;partialView === &#039;comments.partials.comment&#039;\n                &amp;amp;&amp;amp; $broadcast-&amp;gt;partialData[&#039;comment&#039;]-&amp;gt;is($todo-&amp;gt;comments-&amp;gt;first())\n                &amp;amp;&amp;amp; count($broadcast-&amp;gt;channels) === 1\n                &amp;amp;&amp;amp; $broadcast-&amp;gt;channels[0]-&amp;gt;name === sprintf(&#039;private-%s&#039;, $todo-&amp;gt;broadcastChannel());\n        });\n    }\n}\n\n\nNote: If you&#039;re using the automatic model changes broadcasting, make sure your turbo-laravel.queue config key is set to false, otherwise actions may not be dispatched during test because the model observer only fires them after the transaction is committed, which never happens in tests since they run inside a transaction.&quot;",
        "url": "https://turbo-laravel.com/docs/testing",
      },
          "known-issues": {
        "title": "Known Issues",
        "content": "&quot;If you ever encounter an issue with the package, look here first for documented solutions.\n\nFixing Laravel&#039;s Previous URL Issue\n\nVisits from Turbo Frames will hit your application and Laravel by default keeps track of previously visited URLs to be used with helpers like url()-&amp;gt;previous(), for instance. This might be confusing because chances are that you wouldn&#039;t want to redirect users to the URL of the most recent Turbo Frame that hit your app. So, to avoid storing Turbo Frames visits as Laravel&#039;s previous URL, head to the issue where a solution was discussed.&quot;",
        "url": "https://turbo-laravel.com/docs/known-issues",
      },
      }
  </script>
        </div>

              </main>
    </div>
  </div>

        <footer class="px-6 py-4 sm:px-20 sm:py-10 flex items-center space-x-2 justify-between">
          <p class="text-base text-center w-full">
            Turbo Laravel is maintained by <a href="https://tonysm.com" class="underline text-zinc-900/90">Tony Messias</a>. This is a <em>community project</em>, therefore not affiliated with Laravel nor Hotwire.
          </p>
        </footer>
    </body>
</html>
