<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="canonical" href="https://turbo-laravel.com/1.x/docs/search">
        <meta name="description" content="Build web and hybrid navite apps with Laravel and Hotwire today.">
        <title>Turbo Laravel</title>
        <link rel="apple-touch-icon" sizes="180x180" href="/assets/manifest/apple-touch-icon.png">
        <link rel="icon" type="image/png" sizes="32x32" href="/assets/manifest/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/assets/manifest/favicon-16x16.png">
        <link rel="manifest" href="/assets/site.webmanifest">
        <link rel="preload" href="/assets/fonts/OpenSans-ExtraBold.ttf" as="font" type="font/ttf" crossorigin>
        <link rel="preload" href="/assets/fonts/Jost-Regular.woff2" as="font" type="font/woff2" crossorigin>
        <link rel="preload" href="/assets/fonts/Jost-Italic.woff2" as="font" type="font/woff2" crossorigin>
        <link rel="stylesheet" href="/assets/build/css/main.css?id=7c6f8b27ddcb18db8e76e62fda1aa439">
        <script defer src="/assets/build/js/main.js?id=b0f29cd4e71d41b4ee570d0f42344180"></script>

        <!-- Open Graph data -->
        <meta property="og:title" content="Turbo Laravel" />
        <meta property="og:type" content="website" />
        <meta property="og:url" content="" />
        <!-- The image dimensions are necessary otherwise it will not display on LinkedIn -->
        <meta property="og:image" content="/assets/images/turbo-laravel-meta.png" />
        <meta property="og:image:height" content="630" />
        <meta property="og:image:width" content="1200" />
        <meta property="og:description" content="Build web and hybrid navite apps with Laravel and Hotwire today." />
        <meta property="og:locale" content="en_US">
        <meta property="og:site_name" content="Turbo Laravel" />

        <!-- Twitter Card meta -->
        <!-- See documentation linked above for other card types. -->
        <meta name="twitter:card" content="summary_large_image">
        <meta name="twitter:title" content="Turbo Laravel">
        <meta name="twitter:description" content="Build web and hybrid navite apps with Laravel and Hotwire today.">
    </head>
    <body class="text-zinc-900 text-lg font-sans antialiased bg-zinc-700/5 min-h-screen" data-controller="search" data-action="keydown@window->search#focus">
        <header class="px-4 py-6 lg:px-10 xl:px-20 lg:py-10 flex items-center space-x-2 justify-between">
  <div class="relative flex-1 lg:flex-auto flex justify-between items-center space-x-4 sm:space-x-2">
    <h1 class="text-3xl sm:text-4xl font-extrabold font-heading">
      <a href="/">Turbo Laravel</a>
    </h1>

    <nav class="inline-block lg:hidden">
      <details class="group" data-search-target="nav">
        <summary class="list-none">
          <span>
            <span class="sr-only">Navigation</span>

            <svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="size-8 rotate-0 transition group-open:rotate-90">
              <path class="opacity-100 transition group-open:opacity-0" stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5" />
              <path class="transition opacity-0 group-open:opacity-100" stroke-linecap="round" stroke-linejoin="round" d="M6 18 18 6M6 6l12 12" />
            </svg>
          </span>
        </summary>

        <div class="bg-white/50 z-10 absolute top-12 -inset-x-4 backdrop-blur-xl">
          <div class="bg-zinc-700/5 px-4 py-6 backdrop-blur">
            <form action="/1.x/docs/search" method="GET" class="px-4">
  <label for="search" class="sr-only">Search</label>
  <input data-search-target="mobile" type="search" name="q" class="search-input rounded border border-zinc-900/5 px-4 py-2 text-base leading-3 shadow w-full" placeholder="Search 1.x docs..." />
  <button type="submit" class="sr-only">Search</button>
</form>

            <ul class="space-y-6 -mb-2 mt-4">
              <li>
                <a href="/docs" class="px-4 py-2 font-medium rounded-full transition hover:bg-white/90 flex items-center space-x-1">
                  <span>Documentation</span>
                </a>

                  <div class="mx-4 pl-3 border-l-4 border-zinc-900/30">
  <ul class="">
        <li class="px-2 py-1 font-heading font-extrabold uppercase text-sm text-zinc-900/40">Getting Started</li>
    <li class="children mt-2">
      <ul class="list-inside space-y-1 text-lg">
                <li><a href="/1.x/docs/installation" class=" transition hover:bg-zinc-900/20 w-full inline-block px-2 py-1">Installation</a></li>
                <li><a href="/1.x/docs/overview" class=" transition hover:bg-zinc-900/20 w-full inline-block px-2 py-1">Overview</a></li>
                <li><a href="/1.x/docs/conventions" class=" transition hover:bg-zinc-900/20 w-full inline-block px-2 py-1">Conventions</a></li>
              </ul>
    </li>
        <li class="px-2 py-1 font-heading font-extrabold uppercase text-sm text-zinc-900/40">Essentials</li>
    <li class="children mt-2">
      <ul class="list-inside space-y-1 text-lg">
                <li><a href="/1.x/docs/blade-helpers" class=" transition hover:bg-zinc-900/20 w-full inline-block px-2 py-1">Blade Helpers</a></li>
                <li><a href="/1.x/docs/helper-functions" class=" transition hover:bg-zinc-900/20 w-full inline-block px-2 py-1">Helper Functions</a></li>
                <li><a href="/1.x/docs/turbo-streams" class=" transition hover:bg-zinc-900/20 w-full inline-block px-2 py-1">Turbo Streams</a></li>
                <li><a href="/1.x/docs/broadcasting" class=" transition hover:bg-zinc-900/20 w-full inline-block px-2 py-1">Broadcasting</a></li>
                <li><a href="/1.x/docs/livewire" class=" transition hover:bg-zinc-900/20 w-full inline-block px-2 py-1">Livewire Integration</a></li>
                <li><a href="/1.x/docs/validation-response-redirects" class=" transition hover:bg-zinc-900/20 w-full inline-block px-2 py-1">Validation Redirects</a></li>
                <li><a href="/1.x/docs/csrf" class=" transition hover:bg-zinc-900/20 w-full inline-block px-2 py-1">CSRF Protection</a></li>
                <li><a href="/1.x/docs/turbo-native" class=" transition hover:bg-zinc-900/20 w-full inline-block px-2 py-1">Turbo Native</a></li>
                <li><a href="/1.x/docs/testing" class=" transition hover:bg-zinc-900/20 w-full inline-block px-2 py-1">Testing</a></li>
                <li><a href="/1.x/docs/known-issues" class=" transition hover:bg-zinc-900/20 w-full inline-block px-2 py-1">Known Issues</a></li>
              </ul>
    </li>
      </ul>
</div>
              </li>
              <li>
                <a href="https://github.com/hotwired-laravel/turbo-laravel" class="px-4 py-2 font-medium rounded-full transition hover:bg-zinc-900/20">Source Code</a>
              </li>
              <li class="space-y-6">
                <a href="/bootcamp/introduction" class="px-4 py-2 font-medium rounded-full transition hover:bg-white/90">Bootcamp</a>
                              </li>
              <!-- <li><a href="/demo" class="px-4 py-2 font-medium rounded-full transition hover:bg-white/90">Demo</a></li> -->
            </ul>
          </div>
        </div>
      </details>
    </nav>
  </div>

  <nav class="hidden lg:block">
    <ul class="flex items-center space-x-6 -my-2">
      <li>
        <div class="group relative py-2">
          <a href="/docs" class="bg-white/90 px-4 py-2 font-medium rounded-full transition hover:bg-white/90 flex items-center space-x-1">
            <span>Documentation</span>

            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="size-5">
              <path stroke-linecap="round" stroke-linejoin="round" d="m19.5 8.25-7.5 7.5-7.5-7.5" />
            </svg>
          </a>

          <div class="absolute p-4 top-14 inset-x opacity-0 scale-0 -translate-y-8 transition group-hover:translate-y-0 group-hover:scale-100 group-hover:opacity-100 rounded bg-white shadow z-10">
            <ul class="space-y-1">
              <li><a href="/docs/installation" class="block px-2 py-1  rounded">Version <span class="">2.2.0</span></a></li>
              <li><a href="/1.x/docs/installation" class="block px-2 py-1 bg-zinc-900/20 rounded">Version <span class="">1.12.2</span></a></li>
            </ul>
          </div>
        </div>
      </li>
      <li><a href="https://github.com/hotwired-laravel/turbo-laravel" class="px-4 py-2 font-medium rounded-full transition hover:bg-white/90">Source Code</a></li>
      <li><a href="/bootcamp/introduction" class=" px-4 py-2 font-medium rounded-full transition hover:bg-white/90">Bootcamp</a></li>
      <!-- <li><a href="/demo" class=" px-4 py-2 font-medium rounded-full transition hover:bg-white/90">Demo</a></li> -->
    </ul>
  </nav>
</header>

          <div class="bg-white/90 custom-border px-6 py-20 sm:flex space-x-6">
    <div class="sm:flex sm:space-x-12 sm:max-w-7xl w-full mx-auto">
      <aside class="relative w-1/4 hidden lg:block" data-search-target="aside">
        <div class="sticky top-4 block space-y-4">
            <form action="/1.x/docs/search" method="GET">
  <label for="search" class="sr-only">Search</label>
  <input data-search-target="web" type="text" name="q" placeholder="Search v1 docs... (press &quot;/&quot; to focus)" class="search-input rounded border border-zinc-900/5 px-4 py-2 text-base leading-3 shadow w-full" />
</form>

            <ul class="[&_.children]:mb-4 text-base">
    <li class="px-2 py-1 font-heading font-extrabold uppercase text-zinc-900/40">Getting Started</li>
  <li class="children mt-2">
    <ul class="list-inside space-y-1">
            <li><a href="/1.x/docs/installation" class=" transition hover:bg-zinc-900/20 w-full inline-block px-2 py-1 rounded">Installation</a></li>
            <li><a href="/1.x/docs/overview" class=" transition hover:bg-zinc-900/20 w-full inline-block px-2 py-1 rounded">Overview</a></li>
            <li><a href="/1.x/docs/conventions" class=" transition hover:bg-zinc-900/20 w-full inline-block px-2 py-1 rounded">Conventions</a></li>
          </ul>
  </li>
    <li class="px-2 py-1 font-heading font-extrabold uppercase text-zinc-900/40">Essentials</li>
  <li class="children mt-2">
    <ul class="list-inside space-y-1">
            <li><a href="/1.x/docs/blade-helpers" class=" transition hover:bg-zinc-900/20 w-full inline-block px-2 py-1 rounded">Blade Helpers</a></li>
            <li><a href="/1.x/docs/helper-functions" class=" transition hover:bg-zinc-900/20 w-full inline-block px-2 py-1 rounded">Helper Functions</a></li>
            <li><a href="/1.x/docs/turbo-streams" class=" transition hover:bg-zinc-900/20 w-full inline-block px-2 py-1 rounded">Turbo Streams</a></li>
            <li><a href="/1.x/docs/broadcasting" class=" transition hover:bg-zinc-900/20 w-full inline-block px-2 py-1 rounded">Broadcasting</a></li>
            <li><a href="/1.x/docs/livewire" class=" transition hover:bg-zinc-900/20 w-full inline-block px-2 py-1 rounded">Livewire Integration</a></li>
            <li><a href="/1.x/docs/validation-response-redirects" class=" transition hover:bg-zinc-900/20 w-full inline-block px-2 py-1 rounded">Validation Redirects</a></li>
            <li><a href="/1.x/docs/csrf" class=" transition hover:bg-zinc-900/20 w-full inline-block px-2 py-1 rounded">CSRF Protection</a></li>
            <li><a href="/1.x/docs/turbo-native" class=" transition hover:bg-zinc-900/20 w-full inline-block px-2 py-1 rounded">Turbo Native</a></li>
            <li><a href="/1.x/docs/testing" class=" transition hover:bg-zinc-900/20 w-full inline-block px-2 py-1 rounded">Testing</a></li>
            <li><a href="/1.x/docs/known-issues" class=" transition hover:bg-zinc-900/20 w-full inline-block px-2 py-1 rounded">Known Issues</a></li>
          </ul>
  </li>
  </ul>
        </div>
      </aside>

      <main class="flex-1 min-w-0 max-w-3xl">
        <div class="prose prose-lg overflow-hidden prose-zinc [&_code:not(pre_code)]:text-wrap [&_code:not(pre_code)]:break-words prose-headings:font-heading prose-headings:font-extrabold max-w-none w-full">
              <h2>Search results for <em id="search-term" class="text-zinc-900/40"></em></h2>

  <div id="search-results"></div>

  <script>
  window.store = {
          "installation": {
        "title": "Installation",
        "content": "&quot;Turbo Laravel may be installed via Composer:\n\ncomposer require hotwired\/turbo-laravel\n\n\nAfter installing, you may execute the turbo:install Artisan command, which will add a couple JS dependencies to your package.json file (when you&#039;re using Vite and NPM) or to your routes\/importmap.php file (when you&#039;re using Importmap Laravel), publish some JS scripts to your resources\/js folder that configure Turbo.js for you:\n\nphp artisan turbo:install\n\n\nIf you are using Jetstream with Livewire, you may add the --jet flag to the turbo:install Artisan command, which will add a couple more JS dependencies to make sure Alpine.js works nicely with Turbo.js. This will also change the layout that ships with Jetstream files a bit, which will make sure Livewire works nicely as well:\n\nphp artisan turbo:install --jet\n\n\nWhen using Jetstream with Livewire, the Livewire Turbo Plugin is needed so Livewire works nicely with Turbo. This one will be added to your Jetstream layouts as script tags fetching from a CDN (both app.blade.php and guest.blade.php).\n\nIf you&#039;re not using Importmap Laravel, the install command will tell you to pull and compile the assets before proceeding:\n\nnpm install &amp;amp;&amp;amp; npm run build\n\n\nYou may also optionally install Alpine.js in a non-Jetstream context (maybe you&#039;re more into Breeze) passing --alpine flag to the turbo:install Artisan command:\n\nphp artisan turbo:install --alpine\n\n\nNote: the --jet option also adds all the necessary Alpine dependencies since Jetstream depends on Alpine.&quot;",
        "url": "https://turbo-laravel.com/1.x/docs/installation",
      },
          "overview": {
        "title": "Overview",
        "content": "&quot;When Turbo.js is installed, Turbo Drive will be enabled by default. Turbo Drive will turn links and form submissions into fetch requests (AJAX) and will replace the page with the response it gets.\n\nYou will also have Turbo-specific custom HTML tags that you may use in your views to enhance the user experience: Turbo Frames and Turbo Streams. This is vanilla Hotwire. It&#039;s recommended to read the Turbo Handbook. Once you understand how these few pieces work together, the challenge will be in decomposing your UI to work as you want them to.\n\nTurbo also allows you to persist across visits. If you want that to happen, you may annotate these elements with a DOM ID and add the data-turbo-permanent custom attribute to them. As long as the response also contains an element with the same DOM ID and data-turbo-permanent attribute, Turbo will not touch it.\n\nTurbo Drive is nice when you want to have a full page visit. That&#039;s not what we always want, though. Sometimes we want to only swap a fragment of the page and keep everything else as is. That&#039;s what Turbo Frames are all about. Links and Form submissions that are trapped inside a Turbo Frame tag (or that point to one using a data-turbo-frame attribute) will instruct Turbo Drive to NOT replace the entire body of the document, but instead to look for a matching Turbo Frame in the response using its DOM ID and replace that specific portion of the page.\n\nHere&#039;s how you can use Turbo Frames:\n\n&amp;lt;turbo-frame id=&amp;quot;my_frame&amp;quot;&amp;gt;\n    &amp;lt;h1&amp;gt;Hello, World!&amp;lt;\/h1&amp;gt;\n    &amp;lt;a href=&amp;quot;\/somewhere&amp;quot;&amp;gt;\n        I&#039;m a trigger. My response must have a matching Turbo Frame tag (same ID)\n    &amp;lt;\/a&amp;gt;\n&amp;lt;\/turbo-frame&amp;gt;\n\n\nTurbo Frames also allows you to lazy-load the frame&#039;s content. You may do so by adding a src attribute to the Turbo Frame tag. The content of a lazy-loading Turbo Frame tag can be used to indicate \&quot;loading states\&quot;:\n\n&amp;lt;turbo-frame id=&amp;quot;my_frame&amp;quot; :src=&amp;quot;route(&#039;my.page&#039;)&amp;quot;&amp;gt;\n    &amp;lt;p&amp;gt;Loading...&amp;lt;\/p&amp;gt;\n&amp;lt;\/turbo-frame&amp;gt;\n\n\nTurbo will automatically dispatch a fetch request (AJAX) as soon as a lazy-loading Turbo Frame enters the DOM and replace its content with a matching Turbo Frame in the response.\n\nAs mentioned earlier, you may also trigger a Turbo Frame with forms and links that are outside of such frames by pointing to them with a data-turbo-frame attribute:\n\n&amp;lt;div&amp;gt;\n    &amp;lt;a href=&amp;quot;\/somewhere&amp;quot; data-turbo-frame=&amp;quot;my_frame&amp;quot;&amp;gt;I&#039;m a link&amp;lt;\/a&amp;gt;\n\n    &amp;lt;turbo-frame id=&amp;quot;my_frame&amp;quot;&amp;gt;\n        &amp;lt;!-- Content --&amp;gt;\n    &amp;lt;\/turbo-frame&amp;gt;\n&amp;lt;\/div&amp;gt;\n\n\nYou could also \&quot;hide\&quot; this link and trigger a \&quot;click\&quot; event with JavaScript programmatically to trigger the Turbo Frame to reload, for example.\n\nSo far, all vanilla Hotwire and Turbo.&quot;",
        "url": "https://turbo-laravel.com/1.x/docs/overview",
      },
          "conventions": {
        "title": "Conventions",
        "content": "&quot;The conventions described below are NOT mandatory. Feel free to pick what you like and also come up with your own conventions. With that out of the way, here&#039;s a list of conventions you may find helpful.\n\nResource Routes\n\nLaravel supports resource routes and that plays really well with Hotwire for most things. This creates routes names such as posts.index, posts.store, etc.\n\nIf you don&#039;t want to use resource routes, at least consider using the naming convention: render forms in a route name ending in .create or .edit and name their handler routes ending with .store or .update.\n\nYou may define exceptions to the route guessing behavior by setting the redirect_guessing_exceptions in the config\/turbo-laravel.php config file:\n\nreturn [\n    \/\/ ...\n    &#039;redirect_guessing_exceptions&#039; =&amp;gt; [\n        &#039;\/some-page&#039;,\n    ],\n];\n\n\nWhen using this config, the redirection behavior will still happen, but the package will not guess routes. See the Validation Response Redirects page to know more about why this happens.\n\nPartials\n\nYou may want to split up your views in smaller chunks (aka. \&quot;partials\&quot;), such as comments\/_comment.blade.php which displays a comment resource, or comments\/_form.blade.php for the form to either create\/update comments. This will allow you to reuse these partials in Turbo Streams.\n\nThe models&#039; partials (such as the comments\/_comment.blade.php for a Comment model) may only rely on having a single $comment instance variable passed to them. That&#039;s because the package will, by default, figure out the partial for a given model when broadcasting and will also pass the model to such partial, using the class basename as the variable instance in camelCase. Again, that&#039;s by default, you can customize most things. Read the Broadcasting section to know more.\n\nTurbo Stream Channel Names\n\nYou may use the model&#039;s Fully Qualified Class Name (aka. FQCN) as your Broadcasting Channel authorization routes with a wildcard, such as App.Models.Comment.{comment} for a Comment model living in App\\\\Models\\\\ - the wildcard&#039;s name doesn&#039;t matter, as long as there is one. This is the default broadcasting channel naming convention in Laravel.&quot;",
        "url": "https://turbo-laravel.com/1.x/docs/conventions",
      },
          "blade-helpers": {
        "title": "Blade Helpers",
        "content": "&quot;The @domid() Blade Directive\n\nSince Turbo relies a lot on DOM IDs, the package offers a helper to generate unique DOM IDs based on your models. You may use the @domid Blade Directive in your Blade views like so:\n\n&amp;lt;turbo-frame id=&amp;quot;{{&#039;@&#039;}}domid($post)&amp;quot;&amp;gt;\n    &amp;lt;!-- Content --&amp;gt;\n&amp;lt;\/turbo-frame&amp;gt;\n\n\nThis will generate a DOM ID string using your model&#039;s basename and its ID, such as post_123. You may also give it a prefix that will be added to the DOM ID, such as:\n\n&amp;lt;turbo-frame id=&amp;quot;{{&#039;@&#039;}}domid($post, &#039;comments&#039;)&amp;quot;&amp;gt;\n    &amp;lt;!-- Comments --&amp;gt;\n&amp;lt;\/turbo-frame&amp;gt;\n\n\nWhich will generate a comments_post_123 DOM ID, assuming your Post model has an ID of 123.\n\nBlade Components\n\nYou may also prefer using the &amp;lt;x-turbo-frame&amp;gt; Blade component that ships with the package. This way, you don&#039;t need to worry about using the @domid() helper for your Turbo Frame:\n\n&amp;lt;x-turbo-frame :id=&amp;quot;$post&amp;quot;&amp;gt;\n    &amp;lt;!-- Content --&amp;gt;\n&amp;lt;\/x-turbo-frame&amp;gt;\n\n\nTo the :id prop, you may pass a string, which will be used as-is as the DOM ID, an Eloquent model instance, which will be passed to the dom_id() function that ships with the package (the same one as the @domid() Blade directive uses behind the scenes), or an array tuple where the first item is an instance of an Eloquent model and the second is the prefix of the DOM ID, something like this:\n\n&amp;lt;x-turbo-frame :id=&amp;quot;[$post, &#039;comments&#039;]&amp;quot;&amp;gt;\n    &amp;lt;!-- Comments --&amp;gt;\n&amp;lt;\/x-turbo-frame&amp;gt;\n\n\nAdditionally, you may also pass along any prop that is supported by the Turbo Frame custom Element to the &amp;lt;x-turbo-frame&amp;gt; Blade component, like target, src, or loading. These are the listed attributes, but any other attribute will also be forwarded to the &amp;lt;turbo-frame&amp;gt; tag that will be rendered by the &amp;lt;x-turbo-frame&amp;gt; component. For a full list of what&#039;s possible to do with Turbo Frames, see the documentation.&quot;",
        "url": "https://turbo-laravel.com/1.x/docs/blade-helpers",
      },
          "helper-functions": {
        "title": "Helper Functions",
        "content": "&quot;The package ships with a set of helper functions. These functions are all namespaced under Tonysm\\\\TurboLaravel\\\\ but we also add them globally for convenience.\n\nThe dom_id()\n\nThe mentioned namespaced dom_id() helper function may also be used from anywhere in your application, like so:\n\nuse function Tonysm\\TurboLaravel\\dom_id;\n\ndom_id($comment);\n\n\nWhen a new instance of a model is passed to any of these DOM ID helpers, since it doesn&#039;t have an ID, it will prefix the resource name with a create_ prefix. This way, new instances of an App\\\\Models\\\\Comment model will generate a create_comment DOM ID.\n\nThese helpers strip out the model&#039;s FQCN (see config\/turbo-laravel.php if you use an unconventional location for your models).\n\nThe dom_class()\n\nThe dom_class() helper function may be used from anywhere in your application, like so:\n\nuse function Tonysm\\TurboLaravel\\dom_class;\n\ndom_class($comment);\n\n\nThis function will generate the DOM class named based on your model&#039;s classname. If you have an instance of a App\\Models\\Comment model, it will generate a comment DOM class.\n\nSimilar to the dom_id() function, you may also pass a context prefix as the second parameter:\n\ndom_class($comment, &#039;reactions_list&#039;);\n\n\nThis will generate a DOM class of reactions_list_comment.\n\nThe turbo_stream()\n\nYou may generate Turbo Streams using the Response::turboStream() macro, but you may also do so using the turbo_stream() helper function:\n\nuse function Tonysm\\TurboLaravel\\turbo_stream;\n\nturbo_stream()-&amp;gt;append($comment);\n\n\nBoth the Response::turboStream() and the turbo_stream() function work the same way. The turbo_stream() function may be easier to use.\n\nThe turbo_stream_view()\n\nYou may combo Turbo Streams using the turbo_stream([]) function passing an array, but you may prefer to create a separate Blade view with all the Turbo Streams, this way you may also use template extensions and everything else Blade offers:\n\nuse function Tonysm\\TurboLaravel\\turbo_stream_view;\n\nreturn turbo_stream_view(&#039;comments.turbo.created&#039;, [\n    &#039;comment&#039; =&amp;gt; $comment,\n]);\n\n\nAll these functions are also registered globally, so you may use it directly without the use statements (this is useful in contexts like Blade views, for instance).&quot;",
        "url": "https://turbo-laravel.com/1.x/docs/helper-functions",
      },
          "turbo-streams": {
        "title": "Turbo Streams",
        "content": "&quot;Out of everything Turbo provides, it&#039;s Turbo Streams that benefits the most from a tight back-end integration.\n\nTurbo Drive will get your pages behaving like an SPA and Turbo Frames will allow you to have a finer grained control of chunks of your page instead of replacing the entire page when a form is submitted or a link is clicked.\n\nHowever, sometimes you want to update multiple parts of your page at the same time. For instance, after a form submission to create a comment, you may want to append the comment to the comments&#039; list and also update the comments&#039; count in the page. You may achieve that with Turbo Streams.\n\nForm submissions will get annotated by Turbo with a Accept: text\/vnd.turbo-stream.html header (besides the other normal Content Types). This is a signal to the back-end that you can return a Turbo Stream response for that form submission if you want to.\n\nHere&#039;s an example of a route handler detecting and returning a Turbo Stream response to a form submission:\n\nRoute::post(&#039;posts\/{post}\/comments&#039;, function (Post $post) {\n    $comment = $post-&amp;gt;comments()-&amp;gt;create(\/** params *\/);\n\n    if (request()-&amp;gt;wantsTurboStream()) {\n        return response()-&amp;gt;turboStream($comment);\n    }\n\n    return back();\n});\n\n\nThe request()-&amp;gt;wantsTurboStream() macro added to the request class will check if the request accepts Turbo Stream and return true or false accordingly.\n\nThe response()-&amp;gt;turboStream() macro may be used to generate streams, but you may also use the turbo_stream() helper function. From now on, the docs will be using the helper function, but you may use either one of those. Using the function, this example would be:\n\nRoute::post(&#039;posts\/{post}\/comments&#039;, function (Post $post) {\n    $comment = $post-&amp;gt;comments()-&amp;gt;create(\/** params *\/);\n\n    if (request()-&amp;gt;wantsTurboStream()) {\n        return turbo_stream($comment);\n    }\n\n    return back();\n});\n\n\nHere&#039;s what the HTML response will look like:\n\n&amp;lt;turbo-stream action=&amp;quot;append&amp;quot; target=&amp;quot;comments&amp;quot;&amp;gt;\n    &amp;lt;template&amp;gt;\n        &amp;lt;div id=&amp;quot;comment_123&amp;quot;&amp;gt;\n            &amp;lt;p&amp;gt;Hello, World&amp;lt;\/p&amp;gt;\n        &amp;lt;\/div&amp;gt;\n    &amp;lt;\/template&amp;gt;\n&amp;lt;\/turbo-stream&amp;gt;\n\n\nMost of these things were \&quot;guessed\&quot; based on the naming conventions we talked about earlier. But you can override most things, like so:\n\nreturn turbo_stream($comment)-&amp;gt;target(&#039;post_comments&#039;);\n\n\nAlthough it&#039;s handy to pass the model instance to the turbo_stream() function - which will be used to decide the default values of the Turbo Stream response based on the model&#039;s current state, sometimes you may want to build a Turbo Stream response manually:\n\nreturn turbo_stream()\n    -&amp;gt;target(&#039;comments&#039;)\n    -&amp;gt;action(&#039;append&#039;)\n    -&amp;gt;view(&#039;comments._comment&#039;, [&#039;comment&#039; =&amp;gt; $comment]);\n\n\nThere are 7 actions in Turbo Streams. They are:\n\n\nappend &amp;amp; prepend: to insert the elements in the target element at the top or at the bottom, respectively\nbefore &amp;amp; after: to insert the elements next to the target element before or after, respectively\nreplace: will replace the existing element entirely with the contents of the template tag in the Turbo Stream\nupdate: will keep the target element and only replace the contents of it with the contents of the template tag in the Turbo Stream\nremove: will remove the element. This one doesn&#039;t need a template tag. It accepts either an instance of a Model or the DOM ID of the element to be removed as a string.\n\n\nYou will find shorthand methods for them all:\n\nturbo_stream()-&amp;gt;append($comment);\nturbo_stream()-&amp;gt;prepend($comment);\nturbo_stream()-&amp;gt;before($comment);\nturbo_stream()-&amp;gt;after($comment);\nturbo_stream()-&amp;gt;replace($comment);\nturbo_stream()-&amp;gt;update($comment);\nturbo_stream()-&amp;gt;remove($comment);\n\n\nFor these shorthand stream builders, you may pass an instance of an Eloquent model, which will be used to figure out things like target, action, and the view partial as well as the view data passed to them.\n\nAlternatively, you may also pass strings to the shorthand stream builders, which will be used as the target, and an optional content string, which will be rendered instead of a partial, for instance:\n\nturbo_stream()-&amp;gt;append(&#039;statuses&#039;, __(&#039;Comment was successfully created!&#039;));\n\n\nThe optional content parameter expects either a string, a view instance, or an instance of Laravel&#039;s Illuminate\\Support\\HtmlString, so you could do something like:\n\nturbo_stream()-&amp;gt;append(&#039;some_dom_id&#039;, view(&#039;greetings&#039;, [\n    &#039;name&#039; =&amp;gt; &#039;Tester&#039;,\n]));\n\n\nOr more explicitly by passing an instance of the HtmlString as content:\n\nuse Illuminate\\Support\\Facades\\Blade;\nuse Illuminate\\Support\\HtmlString;\n\nturbo_stream()-&amp;gt;append(&#039;statuses&#039;, new HtmlString(\n    Blade::render(&#039;&amp;lt;div&amp;gt;Hello, @{{ $name }}&amp;lt;\/div&amp;gt;&#039;, [&#039;name&#039; =&amp;gt; &#039;Tony&#039;])\n));\n\n\nWhich will result in a Turbo Stream like this:\n\n&amp;lt;turbo-stream target=&amp;quot;statuses&amp;quot; action=&amp;quot;append&amp;quot;&amp;gt;\n    &amp;lt;template&amp;gt;\n        &amp;lt;div&amp;gt;Hello, Tony&amp;lt;\/div&amp;gt;\n    &amp;lt;\/template&amp;gt;\n&amp;lt;\/turbo-stream&amp;gt;\n\n\nFor both the before and after methods you need additional calls to specify the view template you want to insert, since the given model\/string will only be used to specify the target, something like:\n\nturbo_stream()\n    -&amp;gt;before($comment)\n    -&amp;gt;view(&#039;comments._flash_message&#039;, [\n        &#039;message&#039; =&amp;gt; __(&#039;Comment was created!&#039;),\n    ]);\n\n\nJust like the other shorthand stream builders, you may also pass an option content string or HtmlString instance to the before and after shorthands. When doing that, you don&#039;t need to specify the view section.\n\nturbo_stream()-&amp;gt;before($comment, __(&#039;Oh, hey!&#039;));\n\n\nYou can read more about Turbo Streams in the Turbo Handbook.\n\nThe shorthand methods also return a pending Turbo Stream builder which you can chain and override everything you want before it&#039;s rendered:\n\nreturn turbo_stream()\n    -&amp;gt;append($comment)\n    -&amp;gt;view(&#039;comments._comment_card&#039;, [\n        &#039;comment&#039; =&amp;gt; $comment,\n    ]);\n\n\nAs mentioned earlier, passing a model to the turbo_stream() helper will pre-fill the pending response object with some defaults based on the model&#039;s state.\n\nIt will build a remove Turbo Stream if the model was deleted (or if it is trashed - in case it&#039;s a Soft Deleted model), an append if the model was recently created (which you can override the action as the second parameter), a replace if the model was just updated (you can also override the action as the second parameter.) Here&#039;s how overriding would look like:\n\nreturn turbo_stream($comment, &#039;append&#039;);\n\n\nTarget Multiple Elements\n\nYou may also target multiple elements using CSS classes with the xAll methods:\n\nturbo_stream()-&amp;gt;appendAll(&#039;.comment&#039;, &#039;Some content&#039;);\nturbo_stream()-&amp;gt;prependAll(&#039;.comment&#039;, &#039;Some content&#039;);\nturbo_stream()-&amp;gt;updateAll(&#039;.comment&#039;, &#039;Some content&#039;);\nturbo_stream()-&amp;gt;removeAll(&#039;.comment&#039;);\nturbo_stream()-&amp;gt;beforeAll(&#039;.comment&#039;, &#039;Some content&#039;);\nturbo_stream()-&amp;gt;afterAll(&#039;.comment&#039;, &#039;Some content&#039;);\n\n\nWith the exception of the removeAll method, the xAll methods accept as the second parameter a string of inline content, an instance of a View (which may be created using the view() function provided by Laravel), or an instance of the HtmlSafe class.\n\nWhen creating Turbo Streams using the builders, you may also specify the CSS class using the targets() (plural) method instead of the target() (singular) version:\n\nreturn turbo_stream()\n    -&amp;gt;targets(&#039;.comment&#039;)\n    -&amp;gt;action(&#039;append&#039;)\n    -&amp;gt;view(&#039;comments._comment&#039;, [&#039;comment&#039; =&amp;gt; $comment]);\n\n\nTurbo Stream Macros\n\nThe turbo_stream() function returns an instance of PendingTurboStreamResponse, which is macroable. This means you can create your custom DSL for streams. Let&#039;s say you always return flash messages from your controllers like so:\n\nclass ChirpsController extends Controller\n{\n    public function destroy(Request $request, Chirp $chirp)\n    {\n        $this-&amp;gt;authorize(&#039;delete&#039;, $chirp);\n\n        $chirp-&amp;gt;delete();\n\n        if ($request-&amp;gt;wantsTurboStream()) {\n            return turbo_stream([\n                turbo_stream($chirp),\n                turbo_stream()-&amp;gt;append(&#039;notifications&#039;, view(&#039;layouts.notification&#039;, [\n                    &#039;message&#039; =&amp;gt; __(&#039;Chirp deleted.&#039;),\n                ])),\n            ]);\n        }\n\n        \/\/ ...\n    }\n}\n\n\nChances are you&#039;re gonna return flash messages from all your controllers, so you could create a custom macro like so:\n\nclass AppServiceProvider extends ServiceProvider\n{\n    public function boot()\n    {\n        PendingTurboStreamResponse::macro(&#039;flash&#039;, function (string $message) {\n            return $this-&amp;gt;append(&#039;notifications&#039;, view(&#039;layouts.notification&#039;, [\n                &#039;message&#039; =&amp;gt; $message,\n            ]));\n        });\n    }\n}\n\n\nYou could then rewrite that controller like so:\n\nclass ChirpsController extends Controller\n{\n    public function destroy(Request $request, Chirp $chirp)\n    {\n        $this-&amp;gt;authorize(&#039;delete&#039;, $chirp);\n\n        $chirp-&amp;gt;delete();\n\n        if ($request-&amp;gt;wantsTurboStream()) {\n            return turbo_stream([\n                turbo_stream($chirp),\n                turbo_stream()-&amp;gt;append(&#039;notifications&#039;, view(&#039;layouts.notification&#039;, [\n                    &#039;message&#039; =&amp;gt; __(&#039;Chirp deleted.&#039;),\n                ])),\n                turbo_stream()-&amp;gt;flash(__(&#039;Chirp deleted.&#039;)),\n            ]);\n        }\n\n        \/\/ ...\n    }\n}\n\n\nTurbo Streams Combo\n\nYou may combine multiple Turbo Streams in a single response like so:\n\nreturn turbo_stream([\n    turbo_stream()\n        -&amp;gt;append($comment)\n        -&amp;gt;target(dom_id($comment-&amp;gt;post, &#039;comments&#039;)),\n    turbo_stream()\n        -&amp;gt;update(dom_id($comment-&amp;gt;post, &#039;comments_count&#039;), view(&#039;posts._comments_count&#039;, [&#039;post&#039; =&amp;gt; $comment-&amp;gt;post])),\n]);\n\n\nAlthough this is a valid option, it might feel like too much work for a controller. If that&#039;s the case, use Custom Turbo Stream Views.\n\nCustom Turbo Stream Views\n\nAlthough combining Turbo Streams in a single response right there in the controller is a valid option, it may feel like too much work for a controller. If that&#039;s the case, you may want to extract the Turbo Streams to a Blade view and respond with that instead:\n\nreturn response()-&amp;gt;turboStreamView(&#039;comments.turbo.created_stream&#039;, [\n    &#039;comment&#039; =&amp;gt; $comment,\n]);\n\n\nSimilar to the Response::turboStream() macro and the turbo_stream() helper function, you may prefer using the helper function turbo_stream_view():\n\nreturn turbo_stream_view(&#039;comments.turbo.created_stream&#039;, [\n    &#039;comment&#039; =&amp;gt; $comment,\n]);\n\n\nAnd here&#039;s an example of a more complex custom Turbo Stream view:\n\n{{&#039;@&#039;}}include(&#039;layouts.turbo.flash_stream&#039;)\n\n&amp;lt;turbo-stream target=&amp;quot;{{&#039;@&#039;}}domid($comment-&amp;gt;post, &#039;comments&#039;)&amp;quot; action=&amp;quot;append&amp;quot;&amp;gt;\n    &amp;lt;template&amp;gt;\n        {{&#039;@&#039;}}include(&#039;comments._comment&#039;, [&#039;comment&#039; =&amp;gt; $comment])\n    &amp;lt;\/template&amp;gt;\n&amp;lt;\/turbo-stream&amp;gt;\n\n\nRemember, these are Blade views, so you have the full power of Blade at your hands. In this example, we&#039;re including a shared Turbo Stream partial which could append any flash messages we may have. That layouts.turbo.flash_stream could look like this:\n\n{{&#039;@&#039;}}if (session()-&amp;gt;has(&#039;status&#039;))\n&amp;lt;turbo-stream target=&amp;quot;notice&amp;quot; action=&amp;quot;append&amp;quot;&amp;gt;\n    &amp;lt;template&amp;gt;\n        {{&#039;@&#039;}}include(&#039;layouts._flash&#039;)\n    &amp;lt;\/template&amp;gt;\n&amp;lt;\/turbo-stream&amp;gt;\n{{&#039;@&#039;}}endif\n\n\nSimilar to the &amp;lt;x-turbo-frame&amp;gt; Blade component, there&#039;s also a &amp;lt;x-turbo-stream&amp;gt; Blade component that can simplify things a bit. It has the same convention of figuring out the DOM ID when you&#039;re passing a model instance or an array as the &amp;lt;x-turbo-frame&amp;gt; component applied to the target attribute. When using the component version, there&#039;s also no need to specify the template wrapper for the Turbo Stream tag, as that will be added by the component itself. So, the same example would look something like this:\n\n{{&#039;@&#039;}}include(&#039;layouts.turbo.flash_stream&#039;)\n\n&amp;lt;x-turbo-stream :target=&amp;quot;[$comment-&amp;gt;post, &#039;comments&#039;]&amp;quot; action=&amp;quot;append&amp;quot;&amp;gt;\n    {{&#039;@&#039;}}include(&#039;comments._comment&#039;, [&#039;comment&#039; =&amp;gt; $comment])\n&amp;lt;\/x-turbo-stream&amp;gt;\n\n\nI hope you can see how powerful this can be to reusing views.\n\nCustom Actions\n\nWhen you&#039;re using the Blade component, you can use Turbo&#039;s custom actions:\n\n&amp;lt;x-turbo-stream action=&amp;quot;console_log&amp;quot; value=&amp;quot;Hello World&amp;quot; \/&amp;gt;\n\n\nAs you can see, when using custom actions, the &amp;lt;template&amp;gt;&amp;lt;\/template&amp;gt; is also optional. To implement custom actions in the front-end, you&#039;d need something like this:\n\nimport * as Turbo from &#039;{{&#039;@&#039;}}hotwired\/turbo&#039;;\n\nTurbo.StreamActions.console_log = function () {\n    console.log(this.getAttribute(&amp;quot;value&amp;quot;))\n}\n\n\nCustom actions are only supported from Blade views. You cannot return those from controllers using the Pending Streams Builder, for instance.&quot;",
        "url": "https://turbo-laravel.com/1.x/docs/turbo-streams",
      },
          "broadcasting": {
        "title": "Broadcasting",
        "content": "&quot;So far, we have used Turbo Streams over HTTP to handle the case of updating multiple parts of the page for a single user after a form submission. In addition to that, you may want to broadcast model changes over WebSockets to all users that are viewing the same page. Although nice, you don&#039;t have to use WebSockets if you don&#039;t have the need for it. You may still benefit from Turbo Streams over HTTP.\n\nWe can broadcast to all users over WebSockets those exact same Turbo Stream tags we are returning to a user after a form submission. That makes use of Laravel Echo and Laravel&#039;s Broadcasting component.\n\nYou may still feed the user making the changes with Turbo Streams over HTTP and broadcast the changes to other users over WebSockets. This way, the user making the change will have an instant feedback compared to having to wait for a background worker to pick up the job and send it to them over WebSockets.\n\nConfiguration\n\nBroadcasting Turbo Streams relies heavily on Laravel&#039;s Broadcasting component. This means you need to configure Laravel Echo in the frontend and either use Pusher or any other open-source replacement you want to. If you&#039;re not using Pusher, we recommend Soketi since it&#039;s easy to setup.\n\nListening to Broadcasts\n\nYou may listen to a Turbo Stream broadcasts on your pages by adding the custom HTML tag &amp;lt;turbo-echo-stream-source&amp;gt; that is published to your application&#039;s assets (see here). You need to pass the channel you want to listen to broadcasts on using the channel attribute of this element, like so.\n\n&amp;lt;turbo-echo-stream-source\n    channel=&amp;quot;App.Models.Post.@{{ $post-&amp;gt;id }}&amp;quot;\n\/&amp;gt;\n\n\nYou may prefer using the convenient &amp;lt;x-turbo-stream-from&amp;gt; Blade component, passing the model as the source prop to it, something like this:\n\n&amp;lt;x-turbo-stream-from :source=&amp;quot;$post&amp;quot; \/&amp;gt;\n\n\nBy default, it expects a private channel, so the it must be used in a page for already authenticated users. You may control the channel type in the tag with a type attribute.\n\n&amp;lt;x-turbo-stream-from :source=&amp;quot;$post&amp;quot; type=&amp;quot;public&amp;quot; \/&amp;gt;\n\n\nTo register the Broadcast Auth Route you may use Laravel&#039;s built-in conventions as well:\n\n\/\/ file: routes\/channels.php\n\nuse App\\Models\\Post;\nuse App\\Models\\User;\nuse Illuminate\\Support\\Facades\\Broadcast;\n\nBroadcast::channel(Post::class, function (User $user, Post $post) {\n    return $user-&amp;gt;belongsToTeam($post-&amp;gt;team);\n});\n\n\nYou may want to read the Laravel Broadcasting documentation.\n\nBroadcasting Model Changes\n\nWith Laravel Echo properly configured, you may now broadcast model changes using WebSockets. First thing you need to do is use the Broadcasts trait in your model:\n\nuse Tonysm\\TurboLaravel\\Models\\Broadcasts;\n\nclass Comment extends Model\n{\n    use Broadcasts;\n}\n\n\nThis trait will add some methods to your model that you can use to trigger broadcasts. Here&#039;s how you can broadcast appending a new comment to all users visiting the post page:\n\nRoute::post(&#039;posts\/{post}\/comments&#039;, function (Post $post) {\n    $comment = $post-&amp;gt;comments()-&amp;gt;create(\/** params *\/);\n\n    $comment-&amp;gt;broadcastAppend()-&amp;gt;later();\n\n    if (request()-&amp;gt;wantsTurboStream()) {\n        return turbo_stream($comment);\n    }\n\n    return back();\n});\n\n\nHere are the methods now available to your model:\n\n$comment-&amp;gt;broadcastAppend();\n$comment-&amp;gt;broadcastPrepend();\n$comment-&amp;gt;broadcastBefore(&#039;target_dom_id&#039;);\n$comment-&amp;gt;broadcastAfter(&#039;target_dom_id&#039;);\n$comment-&amp;gt;broadcastReplace();\n$comment-&amp;gt;broadcastUpdate();\n$comment-&amp;gt;broadcastRemove();\n\n\nThese methods will assume you want to broadcast the Turbo Streams to your model&#039;s channel. However, you will also find alternative methods where you can specify either a model or the broadcasting channels you want to send the broadcasts to:\n\n$comment-&amp;gt;broadcastAppendTo($post);\n$comment-&amp;gt;broadcastPrependTo($post);\n$comment-&amp;gt;broadcastBeforeTo($post, &#039;target_dom_id&#039;);\n$comment-&amp;gt;broadcastAfterTo($post, &#039;target_dom_id&#039;);\n$comment-&amp;gt;broadcastReplaceTo($post);\n$comment-&amp;gt;broadcastUpdateTo($post);\n$comment-&amp;gt;broadcastRemoveTo($post);\n\n\nThese broadcastXTo() methods accept either a model, a channel instance or an array containing both of these. When it receives a model, it will guess the channel name using the broadcasting channel convention (see #conventions).\n\nAll of these broadcasting methods return an instance of a PendingBroadcast class that will only dispatch the broadcasting job when that pending object is being garbage collected. Which means that you can control a lot of the properties of the broadcast by chaining on that instance before it goes out of scope, like so:\n\n$comment-&amp;gt;broadcastAppend()\n    -&amp;gt;to($post)\n    -&amp;gt;view(&#039;comments\/_custom_view_partial&#039;, [\n        &#039;comment&#039; =&amp;gt; $comment,\n        &#039;post&#039; =&amp;gt; $post,\n    ])\n    -&amp;gt;toOthers() \/\/ Do not send to the current user.\n    -&amp;gt;later(); \/\/ Dispatch a background job to send.\n\n\nYou may want to hook those methods in the model events of your model to trigger Turbo Stream broadcasts whenever your models are changed in any context, such as:\n\nclass Comment extends Model\n{\n    use Broadcasts;\n\n    protected static function booted()\n    {\n        static::created(function (Comment $comment) {\n            $comment-&amp;gt;broadcastPrependTo($comment-&amp;gt;post)\n                -&amp;gt;toOthers()\n                -&amp;gt;later();\n        });\n\n        static::updated(function (Comment $comment) {\n            $comment-&amp;gt;broadcastReplaceTo($comment-&amp;gt;post)\n                -&amp;gt;toOthers()\n                -&amp;gt;later();\n        });\n\n        static::deleted(function (Comment $comment) {\n            $comment-&amp;gt;broadcastRemoveTo($comment-&amp;gt;post)\n                -&amp;gt;toOthers()\n                -&amp;gt;later();\n        });\n    }\n}\n\n\nIn case you want to broadcast all these changes automatically, instead of specifying them all, you may want to add a $broadcasts property to your model, which will instruct the Broadcasts trait to trigger the Turbo Stream broadcasts for the created, updated and deleted model events, like so:\n\nclass Comment extends Model\n{\n    use Broadcasts;\n\n    protected $broadcasts = true;\n}\n\n\nThis will achieve almost the same thing as the example where we registered the model events manually, with a couple nuanced differences. First, by default, it will broadcast an append Turbo Stream to newly created models. You may want to use prepend instead. You can do so by using an array with a insertsBy key and prepend action as value instead of a boolean, like so:\n\nclass Comment extends Model\n{\n    use Broadcasts;\n\n    protected $broadcasts = [\n        &#039;insertsBy&#039; =&amp;gt; &#039;prepend&#039;,\n    ];\n}\n\n\nThis will also automatically hook into the model events, but instead of broadcasting new instances as append it will use prepend.\n\nSecondly, it will send all changes to this model&#039;s broadcasting channel, except for when the model is created (since no one would be listening to its direct channel). In our case, we want to direct the broadcasts to the post linked to this model instead. We can achieve that by adding a $broadcastsTo property to the model, like so:\n\nclass Comment extends Model\n{\n    use Broadcasts;\n\n    protected $broadcasts = [\n        &#039;insertsBy&#039; =&amp;gt; &#039;prepend&#039;,\n    ];\n\n    protected $broadcastsTo = &#039;post&#039;;\n\n    public function post()\n    {\n        return $this-&amp;gt;belongsTo(Post::class);\n    }\n}\n\n\nThat property can either be a string that contains the name of a relationship of this model or an array of relationships.\n\nAlternatively, you may prefer to have more control over where these broadcasts are being sent to by implementing a broadcastsTo method in your model instead of using the property. This way, you can return a single model, a broadcasting channel instance or an array containing either of them, like so:\n\nuse Illuminate\\Broadcasting\\Channel;\n\nclass Comment extends Model\n{\n    use Broadcasts;\n\n    protected $broadcasts = [\n        &#039;insertsBy&#039; =&amp;gt; &#039;prepend&#039;,\n    ];\n\n    public function post()\n    {\n        return $this-&amp;gt;belongsTo(Post::class);\n    }\n\n    public function broadcastsTo()\n    {\n        return [\n            $this,\n            $this-&amp;gt;post,\n            new Channel(&#039;full-control&#039;),\n        ];\n    }\n}\n\n\nNewly created models using the auto-broadcasting feature will be broadcasted to a pluralized version of the model&#039;s basename. So if you have a App\\Models\\PostComment, you may expect broadcasts of newly created models to be sent to a private channel called post_comments. Again, this convention is only valid for newly created models. Updates\/Removals will still be sent to the model&#039;s own private channel by default using Laravel&#039;s convention for channel names. You may want to specify the channel name for newly created models to be broadcast to with the stream key:\n\nclass Comment extends Model\n{\n    use Broadcasts;\n\n    protected $broadcasts = [\n        &#039;stream&#039; =&amp;gt; &#039;some_comments&#039;,\n    ];\n}\n\n\nHaving a $broadcastsTo property or implementing the broadcastsTo() method in your model will have precedence over this, so newly created models will be sent to the channels specified on those places instead of using the convention or the stream option.\n\nBroadcasting Turbo Streams to Other Users Only\n\nAs mentioned earlier, you may want to feed the current user with Turbo Streams using HTTP requests and only send the broadcasts to other users. There are a couple ways you can achieve that.\n\nFirst, you can chain on the broadcasting methods, like so:\n\n$comment-&amp;gt;broadcastAppendTo($post)\n    -&amp;gt;toOthers();\n\n\nSecond, you can use the Turbo Facade like so:\n\nuse Tonysm\\TurboLaravel\\Facades\\Turbo;\n\nTurbo::broadcastToOthers(function () {\n    \/\/ ...\n});\n\n\nThis way, any broadcast that happens inside the scope of the Closure will only be sent to other users.\n\nThird, you may use that same method but without the Closure inside a ServiceProvider, for instance, to instruct the package to only send turbo stream broadcasts to other users globally:\n\n&amp;lt;?php\n\nnamespace App\\Providers;\n\nuse Illuminate\\Support\\ServiceProvider;\nuse Tonysm\\TurboLaravel\\Facades\\Turbo;\n\nclass AppServiceProvider extends ServiceProvider\n{\n    public function boot()\n    {\n        Turbo::broadcastToOthers();\n    }\n}\n\n\nHandmade Broadcasts\n\nYou may want to broadcast something that does not depend on a model. You may do so using the Tonysm\\TurboLaravel\\Facades\\TurboStream Facade (if you&#039;re not into Facades, type-hinting the Tonysm\\TurboLaravel\\Broadcasting\\Factory class should also work):\n\nTurboStream::broadcastAppend(\n    content: __(&#039;Hello World&#039;),\n    target: &#039;notifications&#039;,\n    channel: &#039;general&#039;,\n);\n\n\nModel broadcasts use this same abstraction under the hood, so you have similar methods available:\n\nTurboStream::broadcastAppend();\nTurboStream::broadcastPrepend();\nTurboStream::broadcastBefore();\nTurboStream::broadcastAfter();\nTurboStream::broadcastUpdate();\nTurboStream::broadcastReplace();\nTurboStream::broadcastRemove();\n\n\nAll of these methods, except the broadcastRemove() one, accept a $content parameter that may be a View instance, an instance of the HtmlString class, or a simple string:\n\n\/\/ Passing a view instance as content...\nTurboStream::broadcastAppend(\n    content: view(&#039;layouts.notification&#039;, [&#039;message&#039; =&amp;gt; &#039;Hello World&#039;]),\n    target: &#039;notifications&#039;,\n    channel: &#039;general&#039;,\n);\n\n\/\/ Passing an instance of the HtmlString class (won&#039;t be escaped by Blade)...\nTurboStream::broadcastAppend(\n    content: new HtmlString(&#039;Hello World&#039;),\n    target: &#039;notifications&#039;,\n    channel: &#039;general&#039;,\n);\n\n\/\/ Passing a simple string (will be escaped by Blade)...\nTurboStream::broadcastAppend(\n    content: &#039;Hello World&#039;,\n    target: &#039;notifications&#039;,\n    channel: &#039;general&#039;,\n);\n\n\nYou may also dynamically change the Turbo Stream setting by chaining on the return of that method:\n\nTurboStream::broadcastAppend(&#039;Hello World&#039;)\n    -&amp;gt;target(&#039;notifications&#039;)\n    -&amp;gt;to(&#039;general&#039;);\n\n\nAs for the channel, you may pass a string that will be interpreted as a public channel name, an Eloquent model which will expect a private channel using that model&#039;s broadcasting channel convention, or instances of the Illuminate\\Broadcasting\\Channel class.\n\nYou may want to specify private or presence string channels, which you may do like so:\n\nTurboStream::broadcastAppend(&#039;Hello World&#039;)\n    -&amp;gt;target(&#039;notifications&#039;)\n    -&amp;gt;toPrivateChannel(&#039;user.123&#039;);\n\nTurboStream::broadcastAppend(&#039;Hello World&#039;)\n    -&amp;gt;target(&#039;notifications&#039;)\n    -&amp;gt;toPresenceChannel(&#039;user.123&#039;);\n\n\nAlternatively to broadcasting any of the 7 default broadcasting actions, you may want to broadcast custom Turbo Stream actions, which you can do by using the broadcastAction() method directly (which is the same method used by the other default ones):\n\nTurboStream::broadcastAction(&#039;scroll_to&#039;, target: &#039;todo_123&#039;);\n\n\nHandmade Broadcasting Using The turbo_stream() Response Builder\n\nAlternatively to using the TurboStream Facade (or Factory type-hint), you may also broadcast directly from the turbo_stream() function response builder:\n\nturbo_stream()\n    -&amp;gt;append(&#039;notifications&#039;, &#039;Hello World&#039;)\n    -&amp;gt;broadcastTo(&#039;general&#039;);\n\n\nThis will tap on the PendingTurboStreamResponse and create a PendingBroadcast from the Turbo Stream you configured. It&#039;s important to note that this will return the same PendingTurboStreamResponse, not the PendingBroadcast. If you want to configure the PendingBroadcast that will be generated, you may pass a Closure as the second parameter:\n\nturbo_stream()\n    -&amp;gt;append(&#039;notifications&#039;, &#039;Hello World&#039;)\n    -&amp;gt;broadcastTo(&#039;general&#039;, fn ($broadcast) =&amp;gt; $broadcast-&amp;gt;toOthers());\n\n\nYou may pass a string, an Eloquent model, or an instance of the Illuminate\\Broadcasting\\Channel class as the channel:\n\nturbo_stream($comment)\n    -&amp;gt;broadcastTo($comment-&amp;gt;post, fn ($broadcast) =&amp;gt; $broadcast-&amp;gt;toOthers());\n\n\nSimilar to using the Facade, you may also want to broadcast to private or presence string channels like so:\n\n\/\/ To private channels...\nturbo_stream()\n    -&amp;gt;append(&#039;notifications&#039;, &#039;Hello World&#039;)\n    -&amp;gt;broadcastToPrivateChannel(&#039;user.123&#039;, fn ($broadcast) =&amp;gt; $broadcast-&amp;gt;toOthers())\n\n\/\/ To presence channels...\nturbo_stream()\n    -&amp;gt;append(&#039;notifications&#039;, &#039;Hello World&#039;)\n    -&amp;gt;broadcastToPresenceChannel(&#039;chat.123&#039;, fn ($broadcast) =&amp;gt; $broadcast-&amp;gt;toOthers());&quot;",
        "url": "https://turbo-laravel.com/1.x/docs/broadcasting",
      },
          "livewire": {
        "title": "Livewire",
        "content": "&quot;Hotwire and Livewire can be used together. However, you need to add a JS plugin to make this happen.\n\nThe Livewire\/Turbo Plugin\n\nLivewire has an official plugin that bridges these worlds. It was made for when Turbo.js was called Turbolinks, but it got updated when Hotwire came alive and Turbolinks was renamed to Turbo.js.\n\nTo use it, all we need to do is add the CDN script after the Livewire Scripts, something like this:\n\n    &amp;lt;!-- ... --&amp;gt;\n\n    {{&#039;@&#039;}}livewireScripts\n    &amp;lt;script src=&amp;quot;https:\/\/cdn.jsdelivr.net\/gh\/livewire\/turbolinks{{&#039;@&#039;}}v0.1.x\/dist\/livewire-turbolinks.js&amp;quot; data-turbo-eval=&amp;quot;false&amp;quot;&amp;gt;&amp;lt;\/script&amp;gt;\n&amp;lt;\/body&amp;gt;\n\n\nWhen you install Turbo Laravel using the --jet flag, this gets automatically added to your app and guest layouts, since Jetstream uses Livewire.\n\nDeeper Integration\n\nIt&#039;s possible to get a deeper integration between Livewire and Hotwire using Turbo Streams. Although, we haven&#039;t seen any advancements on that front. There&#039;s an example of such integration in the Turbo Demo App.\n\nIn the example, there&#039;s a Counter Livewire component that has increment and decrement methods. When those are triggered, it manipulates the counter and then dispatches a browser event with a rendered Turbo Stream to update a portion of the page that&#039;s outside of the scope of the Counter Livewire component:\n\n&amp;lt;?php\n\nnamespace App\\Http\\Livewire;\n\nuse Livewire\\Component;\n\nclass Counter extends Component\n{\n    public $counter = 0;\n\n    public function increment()\n    {\n        $this-&amp;gt;counter++;\n\n        $this-&amp;gt;dispatchBrowserEvent(&#039;turboStreamFromLivewire&#039;, [\n            &#039;message&#039; =&amp;gt; view(&#039;livewire.counter_stream&#039;, [&#039;counter&#039; =&amp;gt; $this-&amp;gt;counter])-&amp;gt;render(),\n        ]);\n    }\n\n    public function decrement()\n    {\n        $this-&amp;gt;counter--;\n\n        $this-&amp;gt;dispatchBrowserEvent(&#039;turboStreamFromLivewire&#039;, [\n            &#039;message&#039; =&amp;gt; view(&#039;livewire.counter_stream&#039;, [&#039;counter&#039; =&amp;gt; $this-&amp;gt;counter])-&amp;gt;render(),\n        ]);\n    }\n\n    public function render()\n    {\n        return view(&#039;livewire.counter&#039;);\n    }\n}\n\n\nThen, we can create a custom HTML element that listens to the turboStreamFromLivewire event in the window that simply applies the Turbo Streams that comes from our Livewire Components, something like:\n\nimport { connectStreamSource, disconnectStreamSource } from &amp;quot;{{&#039;@&#039;}}hotwired\/turbo&amp;quot;\n\nclass TurboLivewireStreamSourceElement extends HTMLElement {\n    async connectedCallback() {\n        connectStreamSource(this)\n        window.addEventListener(&#039;turboStreamFromLivewire&#039;, this.dispatchMessageEvent.bind(this));\n    }\n\n    disconnectedCallback() {\n        disconnectStreamSource(this)\n        window.removeEventListener(&#039;turboStreamFromLivewire&#039;, this.dispatchMessageEvent.bind(this));\n    }\n\n    dispatchMessageEvent(data) {\n        const event = new MessageEvent(&amp;quot;message&amp;quot;, { data: data.detail.message })\n        return this.dispatchEvent(event)\n    }\n}\n\nif (customElements.get(&#039;turbo-livewire-stream-source&#039;) === undefined) {\n    customElements.define(&#039;turbo-livewire-stream-source&#039;, TurboLivewireStreamSourceElement)\n}\n\n\nNow, we can use this element in a page where we want to have the integration between Livewire and Turbo.js (or in a base layout if you want it applied application-wide):\n\n&amp;lt;turbo-livewire-stream-source \/&amp;gt;\n\n&amp;lt;livewire:counter \/&amp;gt;\n\n\nThat&#039;s it! With that, we got Livewire to generate Turbo Streams, dispatch it as a browser event, which gets intercepted by our custom HTML element and applied to the page!\n\nThis is only an example of what a deeper integration could look like.&quot;",
        "url": "https://turbo-laravel.com/1.x/docs/livewire",
      },
          "validation-response": {
        "title": "Validation Response",
        "content": "&quot;By default, Laravel will redirect failed validation exceptions \&quot;back\&quot; to the page the triggered the request. This is a bit problematic when it comes to Turbo Frames, since a form might be included in a page that don&#039;t render the form initially, and after a failed validation exception from a form submission we would want to re-render the form with the invalid messages.\n\nIn other words, a Turbo Frame inherits the context of the page where it was inserted in, and a form might not be part of that page itself. We can&#039;t redirect \&quot;back\&quot; to display the form again with the error messages, because the form might not be re-rendered there by default. Instead, we have two options:\n\n\nRender a Blade view with the form as a non-200 HTTP Status Code, then Turbo will look for a matching Turbo Frame inside the response and replace only that portion or page, but it won&#039;t update the URL as it would for other Turbo Visits; or\nRedirect the request to a page that renders the form directly instead of \&quot;back\&quot;. There you can render the validation messages and all that. Turbo will follow the redirect (303 Status Code) and fetch the Turbo Frame with the form and invalid messages and update the existing one.\n\n\nWhen using the TurboMiddleware that ships with this package, we&#039;ll override Laravel&#039;s default error handling for validation exceptions. Instead of redirecting \&quot;back\&quot;, we&#039;ll guess the form route based on the route resource conventions (if you&#039;re using that) and make an internal GET request to that route and return its contents with a 422 status code. So, if you&#039;re using the route resource conventions, validation errors will not respond with redirects, but with 422 status codes instead.\n\nTo guess where the form is located at we rely on the route resource convention. For any route name ending in .store, it will guess that the form can be located at the .create route for the same resource with all the route params from the previous request. In the same way, for any .update routes, it will guess the form is located at the .edit route of the same resource.\n\nExamples:\n\n\nposts.comments.store will guess the form is at the posts.comments.create route with the {post} route param.\ncomments.store will guess the form is at the comments.create route with no route params.\ncomments.update will guess the form is at the comments.edit with the {comment} param.\n\n\nIf a guessed route name doesn&#039;t exist (which will always happen if you don&#039;t use the route resource convention), the middleware will not change the default handling of validation errors.\n\nWhen you&#039;re not using the resource route naming convention, you can override redirect behavior by catching the ValidationException yourself and re-throwing it overriding the redirect with the redirectTo method. If the exception has that, the middleware will respect it and make a GET request to that location instead of trying to guess it.\n\nHere&#039;s how you may set the redirectTo property:\n\npublic function store()\n{\n  try {\n     request()-&amp;gt;validate([&#039;name&#039; =&amp;gt; &#039;required&#039;]);\n  } catch (\\Illuminate\\Validation\\ValidationException $exception) {\n    throw $exception-&amp;gt;redirectTo(url(&#039;\/somewhere&#039;));\n  }\n}\n\n\nYou may want to have exceptions to the route guessing behavior, which you can use the redirect_guessing_exceptions config in the config\/turbo-laravel.php config file:\n\nreturn [\n    \/\/ ...\n    &#039;redirect_guessing_exceptions&#039; =&amp;gt; [\n        &#039;\/some-page&#039;,\n    ],\n];\n\n\nThe internal redirect will still happen, but the resource route convention will not be used.\n\nTurbo HTTP Middleware\n\nThe package ships with a middleware which applies some conventions on your redirects, specially around how failed validations are handled automatically by Laravel. Read more about this in the Conventions section of the documentation.\n\nThe middleware is automatically prepended to your web route group middleware stack. You may want to add the middleware to other groups, when doing so, make sure it&#039;s at the top of the middleware stack:\n\n\\Tonysm\\TurboLaravel\\Http\\Middleware\\TurboMiddleware::class,\n\n\nLike so:\n\nnamespace App\\Http;\n\nuse Illuminate\\Foundation\\Http\\Kernel as HttpKernel;\n\nclass Kernel extends HttpKernel\n{\n    protected $middlewareGroups = [\n        &#039;web&#039; =&amp;gt; [\n            \\Tonysm\\TurboLaravel\\Http\\Middleware\\TurboMiddleware::class,\n            \/\/ other middlewares...\n        ],\n    ];\n}&quot;",
        "url": "https://turbo-laravel.com/1.x/docs/validation-response-redirects",
      },
          "csrf-protection": {
        "title": "CSRF Protection",
        "content": "&quot;Laravel has built-in CSRF protection in place. It essentially prevents our app from processing any non-GET requests that don&#039;t have a valid CSRF Token in them. So, to allow a POST form to be processed, we usually need to add a @csrf Blade directive to our forms:\n\n&amp;lt;form action=&amp;quot;@{{ route(&#039;chirps.store&#039;) }}&amp;quot; method=&amp;quot;post&amp;quot;&amp;gt;\n    {{&#039;@&#039;}}csrf\n\n    &amp;lt;!-- ... --&amp;gt;\n&amp;lt;\/form&amp;gt;\n\n\nSince Turbo.js intercepts form submissions and converts those to fetch requests (AJAX), we don&#039;t actually need the @csrf token applied to each form. Instead, Turbo.js is smart enough to read your page&#039;s meta tags, look for one named csrf-token and use its contents. Jetstream and Breeze both ship with such element, but in case you&#039;re missing it in your views, it should look like this:\n\n&amp;lt;meta name=&amp;quot;csrf-token&amp;quot; content=&amp;quot;@{{ csrf_token() }}&amp;quot;&amp;gt;\n\n\nWith that being said, you may still want to use the @csrf Blade directive if you want to support users with JavaScript disabled, since the forms will still work if they contain the CSRF token.&quot;",
        "url": "https://turbo-laravel.com/1.x/docs/csrf",
      },
          "turbo-native": {
        "title": "Turbo Native",
        "content": "&quot;Hotwire also has a mobile side, and the package provides some goodies on this front too.\n\nTurbo Visits made by a Turbo Native client will send a custom User-Agent header. So we added another Blade helper you may use to toggle fragments or assets (such as mobile specific stylesheets) on and off depending on whether your page is being rendered for a Native app or a Web app:\n\n{{&#039;@&#039;}}turbonative\n    &amp;lt;h1&amp;gt;Hello, Turbo Native Users!&amp;lt;\/h1&amp;gt;\n{{&#039;@&#039;}}endturbonative\n\n\nAlternatively, you can check if it&#039;s not a Turbo Native visit using the @unlessturbonative Blade helpers:\n\n{{&#039;@&#039;}}unlessturbonative\n    &amp;lt;h1&amp;gt;Hello, Non-Turbo Native Users!&amp;lt;\/h1&amp;gt;\n{{&#039;@&#039;}}endunlessturbonative\n\n\nYou may also check if the request was made from a Turbo Native visit using the request macro:\n\nif (request()-&amp;gt;wasFromTurboNative()) {\n    \/\/ ...\n}\n\n\nOr the Turbo Facade directly, like so:\n\nuse Tonysm\\TurboLaravel\\Facades\\Turbo;\n\nif (Turbo::isTurboNativeVisit()) {\n    \/\/ ...\n}\n\n\nInteracting With Turbo Native Navigation\n\nTurbo is built to work with native navigation principles and present those alongside what&#039;s required for the web. When you have Turbo Native clients running (see the Turbo iOS and Turbo Android projects for details), you can respond to native requests with three dedicated responses: recede, resume, refresh.\n\nYou may want to use the provided InteractsWithTurboNativeNavigation trait on your controllers like so:\n\nuse Tonysm\\TurboLaravel\\Http\\Controllers\\Concerns\\InteractsWithTurboNativeNavigation;\n\nclass TraysController extends Controller\n{\n    use InteractsWithTurboNativeNavigation;\n\n    public function store()\n    {\n        $tray = \/** Create the Tray *\/;\n\n        return $this-&amp;gt;recedeOrRedirectTo(route(&#039;trays.show&#039;, $tray));\n    }\n}\n\n\nIn this example, when the request to create trays comes from a Turbo Native request, we&#039;re going to redirect to the turbo_recede_historical_location URL route instead of the trays.show route. However, if the request was made from your web app, we&#039;re going to redirect the client to the trays.show route.\n\nThere are a couple of redirect helpers available:\n\n$this-&amp;gt;recedeOrRedirectTo(string $url);\n$this-&amp;gt;resumeOrRedirectTo(string $url);\n$this-&amp;gt;refreshOrRedirectTo(string $url);\n$this-&amp;gt;recedeOrRedirectBack(string $fallbackUrl, array $options = []);\n$this-&amp;gt;resumeOrRedirectBack(string $fallbackUrl, array $options = []);\n$this-&amp;gt;refreshOrRedirectBack(string $fallbackUrl, array $options = []);\n\n\nThe Turbo Native client should intercept navigations to these special routes and handle them separately. For instance, you may want to close a native modal that was showing a form after its submission and recede to the previous screen dismissing the modal, and not by following the redirect as the web does.\n\nAt the time of this writing, there aren&#039;t much information on how the mobile clients should interact with these routes. However, I wanted to be able to experiment with them, so I brought them to the package for parity (see this comment here).\n\nIf you don&#039;t want these routes enabled, feel free to disable them by commenting out the feature on your config\/turbo-laravel.php file (make sure the Turbo Laravel configs are published):\n\nreturn [\n    &#039;features&#039; =&amp;gt; [\n        \/\/ Features::turboNativeRoutes(),\n    ],\n];&quot;",
        "url": "https://turbo-laravel.com/1.x/docs/turbo-native",
      },
          "testing": {
        "title": "Testing",
        "content": "&quot;There are two aspects of your application using Turbo Laravel that are specific this approach itself:\n\n\nTurbo Stream HTTP responses. As you return Turbo Stream responses from your route handlers\/controllers to be applied by Turbo itself; and\nTurbo Stream broadcasts. Which is the side-effect of certain model changes, or when you call $model-&amp;gt;broadcastAppend() on your models, or when you&#039;re using Handmade Turbo Stream broadcasts.\n\n\nWe&#039;re going to cover both of these scenarios here.\n\nMaking Turbo &amp;amp; Turbo Native HTTP requests\n\nTo enhance your testing capabilities here, Turbo Laravel adds a couple of macros to the TestResponse that Laravel uses under the hood. The goal is that testing Turbo Stream responses is as convenient as testing regular HTTP responses.\n\nTo mimic Turbo requests, which means sending a request setting the correct Content-Type in the Accept: HTTP header, you need to use the InteractsWithTurbo trait to your testcase. Now you can mimic a Turbo HTTP request by using the $this-&amp;gt;turbo() method before you make the HTTP call itself. You can also mimic Turbo Native specific requests by using the $this-&amp;gt;turboNative() also before you make the HTTP call. The first method will add the correct Turbo Stream content type to the Accept: header, and the second method will add Turbo Native User-Agent: value.\n\nThese methods are handy when you are conditionally returning Turbo Stream responses based on the request()-&amp;gt;wantsTurboStream() helper, for instance. Or when using the @turbonative or @unlessturbonative Blade directives.\n\nTesting Turbo Stream HTTP Responses\n\nYou can test if you got a Turbo Stream response by using the assertTurboStream. Similarly, you can assert that your response is not a Turbo Stream response by using the assertNotTurboStream() macro:\n\nuse Tonysm\\TurboLaravel\\Testing\\InteractsWithTurbo;\n\nclass CreateTodosTest extends TestCase\n{\n    use InteractsWithTurbo;\n\n    \/** {{&#039;@&#039;}}test *\/\n    public function creating_todo_from_turbo_request_returns_turbo_stream_response()\n    {\n        $response = $this-&amp;gt;turbo()-&amp;gt;post(route(&#039;todos.store&#039;), [\n            &#039;content&#039; =&amp;gt; &#039;Test the app&#039;,\n        ]);\n\n        $response-&amp;gt;assertTurboStream();\n    }\n\n    \/** {{&#039;@&#039;}}test *\/\n    public function creating_todo_from_regular_request_does_not_return_turbo_stream_response()\n    {\n        \/\/ Notice we&#039;re not chaining the `$this-&amp;gt;turbo()` method here.\n        $response = $this-&amp;gt;post(route(&#039;todos.store&#039;), [\n            &#039;content&#039; =&amp;gt; &#039;Test the app&#039;,\n        ]);\n\n        $response-&amp;gt;assertNotTurboStream();\n    }\n}\n\n\nThe controller for such response would be something like this:\n\nclass TodosController\n{\n    public function store()\n    {\n        $todo = auth()-&amp;gt;user()-&amp;gt;todos()-&amp;gt;create(request()-&amp;gt;validate([\n            &#039;content&#039; =&amp;gt; [&#039;required&#039;],\n        ]));\n\n        if (request()-&amp;gt;wantsTurboStream()) {\n            return response()-&amp;gt;turboStream($todo);\n        }\n\n        return redirect()-&amp;gt;route(&#039;todos.index&#039;);\n    }\n}\n\n\nFluent Turbo Stream Testing\n\nYou can get specific on your Turbo Stream responses by passing a callback to the assertTurboStream(fn) method. This can be used to test that you have a specific Turbo Stream tag being returned, or that you&#039;re returning exactly 2 Turbo Stream tags, for instance:\n\n\/** {{&#039;@&#039;}}test *\/\npublic function create_todos()\n{\n    $this-&amp;gt;get(route(&#039;todos.store&#039;))\n        -&amp;gt;assertTurboStream(fn (AssertableTurboStream $turboStreams) =&amp;gt; (\n            $turboStreams-&amp;gt;has(2)\n            &amp;amp;&amp;amp; $turboStreams-&amp;gt;hasTurboStream(fn ($turboStream) =&amp;gt; (\n                $turboStream-&amp;gt;where(&#039;target&#039;, &#039;flash_messages&#039;)\n                            -&amp;gt;where(&#039;action&#039;, &#039;prepend&#039;)\n                            -&amp;gt;see(&#039;Todo was successfully created!&#039;)\n            ))\n            &amp;amp;&amp;amp; $turboStreams-&amp;gt;hasTurboStream(fn ($turboStream) =&amp;gt; (\n                $turboStream-&amp;gt;where(&#039;target&#039;, &#039;todos&#039;)\n                            -&amp;gt;where(&#039;action&#039;, &#039;append&#039;)\n                            -&amp;gt;see(&#039;Test the app&#039;)\n            ))\n        ));\n}\n\n\nTesting Turbo Stream Broadcasts\n\nAll broadcasts use the TurboStream Facade. You may want to fake it so you can that the broadcasts are being correctly sent:\n\nuse App\\Models\\Todo;\nuse Tonysm\\TurboLaravel\\Facades\\TurboStream;\nuse Tonysm\\TurboLaravel\\Broadcasting\\PendingBroadcast;\n\nclass CreatesCommentsTest extends TestCase\n{\n    \/** {{&#039;@&#039;}}test *\/\n    public function content_is_required()\n    {\n        TurboStream::fake();\n\n        $todo = Todo::factory()-&amp;gt;create();\n\n        $this-&amp;gt;turbo()-&amp;gt;post(route(&#039;todos.comments.store&#039;, $todo), [\n            &#039;content&#039; =&amp;gt; null,\n        ])-&amp;gt;assertInvalid([&#039;content&#039;]);\n\n        TurboStream::assertNothingWasBroadcasted();\n    }\n\n    \/** {{&#039;@&#039;}}test *\/\n    public function creates_comments()\n    {\n        TurboStream::fake();\n\n        $todo = Todo::factory()-&amp;gt;create();\n\n        $this-&amp;gt;turbo()-&amp;gt;post(route(&#039;todos.comments.store&#039;, $todo), [\n            &#039;content&#039; =&amp;gt; &#039;Hey, this is really nice!&#039;,\n        ])-&amp;gt;assertTurboStream();\n\n        TurboStream::assertBroadcasted(function (PendingBroadcast $broadcast) use ($todo) {\n            return $broadcast-&amp;gt;target === &#039;comments&#039;\n                &amp;amp;&amp;amp; $broadcast-&amp;gt;action === &#039;append&#039;\n                &amp;amp;&amp;amp; $broadcast-&amp;gt;partialView === &#039;comments._comment&#039;\n                &amp;amp;&amp;amp; $broadcast-&amp;gt;partialData[&#039;comment&#039;]-&amp;gt;is($todo-&amp;gt;comments-&amp;gt;first())\n                &amp;amp;&amp;amp; count($broadcast-&amp;gt;channels) === 1\n                &amp;amp;&amp;amp; $broadcast-&amp;gt;channels[0]-&amp;gt;name === sprintf(&#039;private-%s&#039;, $todo-&amp;gt;broadcastChannel());\n        });\n    }\n}\n\n\nNote: If you&#039;re using the automatic model changes broadcasting, make sure your turbo-laravel.queue config key is set to false, otherwise actions may not be dispatched during test because the model observer only fires them after the transaction is committed, which never happens in tests since they run inside a transaction.&quot;",
        "url": "https://turbo-laravel.com/1.x/docs/testing",
      },
          "known-issues": {
        "title": "Known Issues",
        "content": "&quot;If you ever encounter an issue with the package, look here first for documented solutions.\n\nFixing Laravel&#039;s Previous URL Issue\n\nVisits from Turbo Frames will hit your application and Laravel by default keeps track of previously visited URLs to be used with helpers like url()-&amp;gt;previous(), for instance. This might be confusing because chances are that you wouldn&#039;t want to redirect users to the URL of the most recent Turbo Frame that hit your app. So, to avoid storing Turbo Frames visits as Laravel&#039;s previous URL, head to the issue where a solution was discussed.&quot;",
        "url": "https://turbo-laravel.com/1.x/docs/known-issues",
      },
      }
  </script>
        </div>

              </main>
    </div>
  </div>

        <footer class="px-6 py-4 sm:px-20 sm:py-10 flex items-center space-x-2 justify-between">
          <p class="text-base text-center w-full">
            Turbo Laravel is maintained by <a href="https://tonysm.com" class="underline text-zinc-900/90">Tony Messias</a>. This is a <em>community project</em>, therefore not affiliated with Laravel nor Hotwire.
          </p>
        </footer>
    </body>
</html>
